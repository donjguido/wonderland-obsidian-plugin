/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EvergreenAIPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types.ts
var DEFAULT_FOLDER_SETTINGS = {
  customInstructions: "",
  // Folder goal
  folderGoal: "learn",
  customGoalDescription: "",
  titleStyle: "concept",
  includeMetadata: true,
  // External links
  includeExternalLinks: false,
  maxExternalLinks: 3,
  maxPlaceholderLinks: 7,
  autoGeneratePlaceholders: true,
  autoGenerateEmptyNotes: true,
  includeFollowUpQuestions: true,
  // Customizable suggestions
  customizeSuggestions: false,
  userInterests: "",
  autoOrganize: false,
  organizeOnInterval: false,
  organizeIntervalMinutes: 30,
  organizeOnNoteCount: false,
  organizeNoteCountThreshold: 10,
  notesSinceLastOrganize: 0,
  autoClassifyNewNotes: true,
  autoUpdateNotes: false,
  autoUpdateMode: "append",
  autoUpdateIntervalMinutes: 60,
  enableRabbitHolesIndex: false,
  autoUpdateRabbitHolesIndex: false
};
var DEFAULT_SETTINGS = {
  aiProvider: "openai",
  apiKey: "",
  apiEndpoint: "",
  model: "gpt-4o-mini",
  maxTokens: 2e3,
  temperature: 0.7,
  wonderlandFolders: [],
  // Start empty, user picks existing folders
  selectedFolderIndex: 0,
  hasShownWelcome: false,
  placeholderIndicator: "\u2728",
  enableSuggestions: true,
  suggestionFrequency: "daily"
};
function createFolderSettings(path) {
  return {
    path,
    ...DEFAULT_FOLDER_SETTINGS
  };
}
var PROVIDER_DEFAULTS = {
  openai: {
    endpoint: "https://api.openai.com/v1/chat/completions",
    models: ["gpt-4o", "gpt-4o-mini", "gpt-4-turbo", "gpt-4", "gpt-3.5-turbo"]
  },
  anthropic: {
    endpoint: "https://api.anthropic.com/v1/messages",
    models: ["claude-sonnet-4-20250514", "claude-3-5-sonnet-20241022", "claude-3-5-haiku-20241022", "claude-3-haiku-20240307", "claude-3-opus-20240229"]
  },
  ollama: {
    endpoint: "http://localhost:11434/api/chat",
    models: ["llama3.2", "llama3.1", "mistral", "mixtral", "codellama"]
  },
  custom: {
    endpoint: "",
    models: []
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var EvergreenAISettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Wonderland Settings" });
    containerEl.createEl("h2", { text: "AI Configuration" });
    new import_obsidian.Setting(containerEl).setName("AI Provider").setDesc("Select your AI provider").addDropdown(
      (dropdown) => dropdown.addOptions({
        openai: "OpenAI",
        anthropic: "Anthropic (Claude)",
        ollama: "Ollama (Local)",
        custom: "Custom Endpoint"
      }).setValue(this.plugin.settings.aiProvider).onChange(async (value) => {
        this.plugin.settings.aiProvider = value;
        const defaults = PROVIDER_DEFAULTS[value];
        if (defaults.models.length > 0) {
          this.plugin.settings.model = defaults.models[0];
        }
        if (defaults.endpoint) {
          this.plugin.settings.apiEndpoint = defaults.endpoint;
        }
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.aiProvider !== "ollama") {
      new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Your API key (stored locally, never sent anywhere except the AI provider)").addText(
        (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
          this.plugin.settings.apiKey = value;
          await this.plugin.saveSettings();
        })
      ).then((setting) => {
        const inputEl = setting.controlEl.querySelector("input");
        if (inputEl) {
          inputEl.type = "password";
        }
      });
    }
    if (this.plugin.settings.aiProvider === "custom" || this.plugin.settings.aiProvider === "ollama") {
      new import_obsidian.Setting(containerEl).setName("API Endpoint").setDesc("The API endpoint URL").addText(
        (text) => text.setPlaceholder("https://api.example.com/v1/chat/completions").setValue(this.plugin.settings.apiEndpoint).onChange(async (value) => {
          this.plugin.settings.apiEndpoint = value;
          await this.plugin.saveSettings();
        })
      );
    }
    const providerModels = PROVIDER_DEFAULTS[this.plugin.settings.aiProvider].models;
    if (providerModels.length > 0) {
      new import_obsidian.Setting(containerEl).setName("Model").setDesc("Select the AI model to use").addDropdown((dropdown) => {
        const options = {};
        providerModels.forEach((model) => {
          options[model] = model;
        });
        return dropdown.addOptions(options).setValue(this.plugin.settings.model).onChange(async (value) => {
          this.plugin.settings.model = value;
          await this.plugin.saveSettings();
        });
      });
    } else {
      new import_obsidian.Setting(containerEl).setName("Model").setDesc("Enter the model name").addText(
        (text) => text.setPlaceholder("gpt-4").setValue(this.plugin.settings.model).onChange(async (value) => {
          this.plugin.settings.model = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian.Setting(containerEl).setName("Max Tokens").setDesc("Maximum tokens in AI response (affects note length)").addSlider(
      (slider) => slider.setLimits(500, 4e3, 100).setValue(this.plugin.settings.maxTokens).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxTokens = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Temperature").setDesc("Controls randomness (0 = focused, 1 = creative)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Test AI Connection").setDesc("Verify your API configuration is working").addButton(
      (button) => button.setButtonText("Test Connection").setCta().onClick(async () => {
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          await this.plugin.aiService.testConnection();
          button.setButtonText("Connected!");
          setTimeout(() => {
            button.setButtonText("Test Connection");
            button.setDisabled(false);
          }, 2e3);
        } catch (error) {
          button.setButtonText("Failed - Check Settings");
          setTimeout(() => {
            button.setButtonText("Test Connection");
            button.setDisabled(false);
          }, 3e3);
        }
      })
    );
    containerEl.createEl("h2", { text: "Wonderland Folders" });
    containerEl.createEl("p", {
      text: "Select existing folders to become wonderlands of knowledge. Each folder can have its own settings.",
      cls: "setting-item-description"
    });
    this.renderConfiguredFolders(containerEl);
    this.renderFolderPicker(containerEl);
    if (this.plugin.settings.wonderlandFolders.length > 0) {
      this.renderFolderSettings(containerEl);
    }
  }
  renderConfiguredFolders(containerEl) {
    const foldersContainer = containerEl.createDiv({ cls: "wonderland-folders-list" });
    if (this.plugin.settings.wonderlandFolders.length === 0) {
      foldersContainer.createEl("p", {
        text: "No Wonderland folders configured yet. Add one below.",
        cls: "setting-item-description"
      });
      return;
    }
    for (let i = 0; i < this.plugin.settings.wonderlandFolders.length; i++) {
      const folder = this.plugin.settings.wonderlandFolders[i];
      const isSelected = i === this.plugin.settings.selectedFolderIndex;
      const folderItem = foldersContainer.createDiv({ cls: "wonderland-folder-item" });
      folderItem.style.display = "flex";
      folderItem.style.alignItems = "center";
      folderItem.style.justifyContent = "space-between";
      folderItem.style.padding = "8px 12px";
      folderItem.style.marginBottom = "4px";
      folderItem.style.backgroundColor = isSelected ? "var(--interactive-accent)" : "var(--background-secondary)";
      folderItem.style.color = isSelected ? "var(--text-on-accent)" : "inherit";
      folderItem.style.borderRadius = "6px";
      folderItem.style.cursor = "pointer";
      const folderInfo = folderItem.createDiv();
      folderInfo.createSpan({ text: "\u{1F4C1} " });
      const folderName = folderInfo.createSpan({ text: folder.path });
      folderName.style.fontFamily = "var(--font-monospace)";
      folderName.style.fontWeight = isSelected ? "bold" : "normal";
      if (isSelected) {
        folderInfo.createSpan({ text: " (editing)", cls: "setting-item-description" });
      }
      folderItem.addEventListener("click", async () => {
        this.plugin.settings.selectedFolderIndex = i;
        await this.plugin.saveSettings();
        this.display();
      });
      const removeBtn = folderItem.createEl("button", { text: "\xD7" });
      removeBtn.style.marginLeft = "8px";
      removeBtn.style.padding = "2px 8px";
      removeBtn.style.cursor = "pointer";
      removeBtn.style.backgroundColor = "transparent";
      removeBtn.style.border = "none";
      removeBtn.style.color = isSelected ? "var(--text-on-accent)" : "var(--text-muted)";
      removeBtn.addEventListener("click", async (e) => {
        e.stopPropagation();
        this.plugin.settings.wonderlandFolders.splice(i, 1);
        if (this.plugin.settings.selectedFolderIndex >= this.plugin.settings.wonderlandFolders.length) {
          this.plugin.settings.selectedFolderIndex = Math.max(0, this.plugin.settings.wonderlandFolders.length - 1);
        }
        await this.plugin.saveSettings();
        this.display();
      });
    }
  }
  renderFolderPicker(containerEl) {
    const allFolders = this.plugin.getAllVaultFolders();
    const configuredPaths = this.plugin.settings.wonderlandFolders.map((f) => f.path);
    const availableFolders = allFolders.filter((f) => !configuredPaths.includes(f));
    if (availableFolders.length === 0 && allFolders.length > 0) {
      new import_obsidian.Setting(containerEl).setName("All folders configured").setDesc("All available folders are already Wonderland folders");
      return;
    }
    new import_obsidian.Setting(containerEl).setName("Add Wonderland folder").setDesc("Select an existing folder to become a Wonderland").addDropdown((dropdown) => {
      dropdown.addOption("", "-- Select a folder --");
      for (const folder of availableFolders) {
        dropdown.addOption(folder, folder);
      }
      return dropdown.onChange(async (value) => {
        if (value) {
          const newFolderSettings = createFolderSettings(value);
          this.plugin.settings.wonderlandFolders.push(newFolderSettings);
          this.plugin.settings.selectedFolderIndex = this.plugin.settings.wonderlandFolders.length - 1;
          await this.plugin.saveSettings();
          this.display();
        }
      });
    });
  }
  renderFolderSettings(containerEl) {
    const folderSettings = this.plugin.selectedFolderSettings;
    if (!folderSettings)
      return;
    containerEl.createEl("h2", { text: `Settings for: ${folderSettings.path}` });
    containerEl.createEl("h3", { text: "Folder Goal" });
    new import_obsidian.Setting(containerEl).setName("Content focus").setDesc("How AI should approach generating content for this Wonderland").addDropdown(
      (dropdown) => dropdown.addOptions({
        learn: "\u{1F4DA} Learning - Understanding and retention",
        action: "\u2705 Action-Oriented - Practical steps and how-to guides",
        reflect: "\u{1F914} Critical Reflection - Deep thinking and analysis",
        research: "\u{1F52C} Research - Evidence-based with citations",
        creative: "\u{1F3A8} Creative - Imaginative connections",
        custom: "\u2699\uFE0F Custom - Define your own focus"
      }).setValue(folderSettings.folderGoal || "learn").onChange(async (value) => {
        folderSettings.folderGoal = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (folderSettings.folderGoal === "custom") {
      new import_obsidian.Setting(containerEl).setName("Custom goal description").setDesc("Describe the focus for this Wonderland").addTextArea(
        (text) => text.setPlaceholder('e.g., "Focus on comparing different philosophical perspectives"').setValue(folderSettings.customGoalDescription || "").onChange(async (value) => {
          folderSettings.customGoalDescription = value;
          await this.plugin.saveSettings();
        })
      ).then((setting) => {
        const textarea = setting.controlEl.querySelector("textarea");
        if (textarea) {
          textarea.style.width = "100%";
          textarea.style.minHeight = "60px";
        }
      });
    }
    containerEl.createEl("h3", { text: "Custom Instructions" });
    new import_obsidian.Setting(containerEl).setName("Custom instructions for this Wonderland").setDesc('Special instructions for how notes should be generated (e.g., "Generate notes as step-by-step cooking guides" or "Write in a formal academic style")').addTextArea(
      (text) => text.setPlaceholder('e.g., "Generate notes as step-by-step cooking guides with ingredients lists"').setValue(folderSettings.customInstructions || "").onChange(async (value) => {
        folderSettings.customInstructions = value;
        await this.plugin.saveSettings();
      })
    ).then((setting) => {
      const textarea = setting.controlEl.querySelector("textarea");
      if (textarea) {
        textarea.style.width = "100%";
        textarea.style.minHeight = "80px";
      }
    });
    containerEl.createEl("h3", { text: "External References" });
    new import_obsidian.Setting(containerEl).setName("Include external links").setDesc("Add external reference links to reputable sources in generated notes").addToggle(
      (toggle) => toggle.setValue(folderSettings.includeExternalLinks || false).onChange(async (value) => {
        folderSettings.includeExternalLinks = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (folderSettings.includeExternalLinks) {
      new import_obsidian.Setting(containerEl).setName("Max external links").setDesc("Maximum number of external reference links per note").addSlider(
        (slider) => slider.setLimits(1, 10, 1).setValue(folderSettings.maxExternalLinks || 3).setDynamicTooltip().onChange(async (value) => {
          folderSettings.maxExternalLinks = value;
          await this.plugin.saveSettings();
        })
      );
    }
    containerEl.createEl("h3", { text: "Personalized Suggestions" });
    new import_obsidian.Setting(containerEl).setName('Customize "Down the rabbit hole" suggestions').setDesc("Base exploration suggestions on your interests").addToggle(
      (toggle) => toggle.setValue(folderSettings.customizeSuggestions || false).onChange(async (value) => {
        folderSettings.customizeSuggestions = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (folderSettings.customizeSuggestions) {
      new import_obsidian.Setting(containerEl).setName("Your interests").setDesc("Comma-separated list of topics to personalize suggestions").addText(
        (text) => text.setPlaceholder("e.g., philosophy, AI, cooking, music").setValue(folderSettings.userInterests || "").onChange(async (value) => {
          folderSettings.userInterests = value;
          await this.plugin.saveSettings();
        })
      ).then((setting) => {
        const input = setting.controlEl.querySelector("input");
        if (input) {
          input.style.width = "100%";
        }
      });
    }
    containerEl.createEl("h3", { text: "Note Generation" });
    new import_obsidian.Setting(containerEl).setName("Title Style").setDesc("How to format note titles").addDropdown(
      (dropdown) => dropdown.addOptions({
        concept: "Concept (statement form)",
        question: "Question (interrogative)",
        statement: "Statement (declarative)"
      }).setValue(folderSettings.titleStyle).onChange(async (value) => {
        folderSettings.titleStyle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Include Metadata").setDesc("Add YAML frontmatter with generation info").addToggle(
      (toggle) => toggle.setValue(folderSettings.includeMetadata).onChange(async (value) => {
        folderSettings.includeMetadata = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Placeholder Links" });
    new import_obsidian.Setting(containerEl).setName("Max Placeholder Links").setDesc("Maximum concept links to generate per note").addSlider(
      (slider) => slider.setLimits(1, 15, 1).setValue(folderSettings.maxPlaceholderLinks).setDynamicTooltip().onChange(async (value) => {
        folderSettings.maxPlaceholderLinks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-generate on click").setDesc("Automatically generate notes when clicking placeholder links").addToggle(
      (toggle) => toggle.setValue(folderSettings.autoGeneratePlaceholders).onChange(async (value) => {
        folderSettings.autoGeneratePlaceholders = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-explore empty notes").setDesc("Automatically generate content when opening an empty note from a link").addToggle(
      (toggle) => toggle.setValue(folderSettings.autoGenerateEmptyNotes).onChange(async (value) => {
        folderSettings.autoGenerateEmptyNotes = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Include rabbit hole questions").setDesc("Add clickable questions at the end of notes").addToggle(
      (toggle) => toggle.setValue(folderSettings.includeFollowUpQuestions).onChange(async (value) => {
        folderSettings.includeFollowUpQuestions = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Auto-Organization" });
    new import_obsidian.Setting(containerEl).setName("Auto-classify new notes").setDesc("Automatically place new notes into appropriate subfolders").addToggle(
      (toggle) => toggle.setValue(folderSettings.autoClassifyNewNotes).onChange(async (value) => {
        folderSettings.autoClassifyNewNotes = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable auto-organize").setDesc("Allow AI to organize this folder into intuitive subfolders").addToggle(
      (toggle) => toggle.setValue(folderSettings.autoOrganize).onChange(async (value) => {
        folderSettings.autoOrganize = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (folderSettings.autoOrganize) {
      new import_obsidian.Setting(containerEl).setName("Organize on interval").setDesc("Automatically organize periodically").addToggle(
        (toggle) => toggle.setValue(folderSettings.organizeOnInterval).onChange(async (value) => {
          folderSettings.organizeOnInterval = value;
          await this.plugin.saveSettings();
          this.display();
        })
      );
      if (folderSettings.organizeOnInterval) {
        new import_obsidian.Setting(containerEl).setName("Organization interval (minutes)").setDesc("How often to auto-organize").addSlider(
          (slider) => slider.setLimits(5, 120, 5).setValue(folderSettings.organizeIntervalMinutes).setDynamicTooltip().onChange(async (value) => {
            folderSettings.organizeIntervalMinutes = value;
            await this.plugin.saveSettings();
          })
        );
      }
      new import_obsidian.Setting(containerEl).setName("Organize on note count").setDesc("Reorganize after a certain number of new notes are added").addToggle(
        (toggle) => toggle.setValue(folderSettings.organizeOnNoteCount).onChange(async (value) => {
          folderSettings.organizeOnNoteCount = value;
          await this.plugin.saveSettings();
          this.display();
        })
      );
      if (folderSettings.organizeOnNoteCount) {
        new import_obsidian.Setting(containerEl).setName("Note count threshold").setDesc(`Reorganize every X new notes (currently ${folderSettings.notesSinceLastOrganize || 0} since last organize)`).addSlider(
          (slider) => slider.setLimits(3, 50, 1).setValue(folderSettings.organizeNoteCountThreshold).setDynamicTooltip().onChange(async (value) => {
            folderSettings.organizeNoteCountThreshold = value;
            await this.plugin.saveSettings();
          })
        );
      }
      new import_obsidian.Setting(containerEl).setName("Organize now").setDesc("Manually trigger organization").addButton(
        (button) => button.setButtonText("Organize Folder").onClick(async () => {
          button.setButtonText("Organizing...");
          button.setDisabled(true);
          await this.plugin.organizeWonderlandFolder(folderSettings);
          button.setButtonText("Organize Folder");
          button.setDisabled(false);
        })
      );
    }
    containerEl.createEl("h3", { text: "Knowledge Enrichment" });
    new import_obsidian.Setting(containerEl).setName("Auto-update notes").setDesc("Periodically enrich notes with insights from related notes").addToggle(
      (toggle) => toggle.setValue(folderSettings.autoUpdateNotes).onChange(async (value) => {
        folderSettings.autoUpdateNotes = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (folderSettings.autoUpdateNotes) {
      new import_obsidian.Setting(containerEl).setName("Update mode").setDesc("How to add new insights to notes").addDropdown(
        (dropdown) => dropdown.addOptions({
          append: "Append (add section at the end)",
          integrate: "Integrate (weave into content)"
        }).setValue(folderSettings.autoUpdateMode).onChange(async (value) => {
          folderSettings.autoUpdateMode = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Update interval (minutes)").setDesc("How often to check for and add new insights").addSlider(
        (slider) => slider.setLimits(15, 240, 15).setValue(folderSettings.autoUpdateIntervalMinutes).setDynamicTooltip().onChange(async (value) => {
          folderSettings.autoUpdateIntervalMinutes = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Enrich all notes now").setDesc("Manually trigger enrichment of all notes in this folder").addButton(
        (button) => button.setButtonText("Enrich All Notes").onClick(async () => {
          button.setButtonText("Enriching...");
          button.setDisabled(true);
          await this.plugin.autoUpdateFolderNotes(folderSettings);
          button.setButtonText("Enrich All Notes");
          button.setDisabled(false);
        })
      );
    }
    containerEl.createEl("h3", { text: "Rabbit Holes Index" });
    containerEl.createEl("p", {
      text: "The Rabbit Holes Index shows all unresolved links (unexplored paths) in this Wonderland.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Enable Rabbit Holes Index").setDesc("Create and maintain an index of all unresolved links").addToggle(
      (toggle) => toggle.setValue(folderSettings.enableRabbitHolesIndex).onChange(async (value) => {
        folderSettings.enableRabbitHolesIndex = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (folderSettings.enableRabbitHolesIndex) {
      new import_obsidian.Setting(containerEl).setName("Auto-update Rabbit Holes").setDesc("Update the index each time a new note is generated").addToggle(
        (toggle) => toggle.setValue(folderSettings.autoUpdateRabbitHolesIndex).onChange(async (value) => {
          folderSettings.autoUpdateRabbitHolesIndex = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian.Setting(containerEl).setName("Generate Rabbit Holes Index").setDesc("Create or update the Rabbit Holes index").addButton(
      (button) => button.setButtonText("Generate Index").onClick(async () => {
        button.setButtonText("Generating...");
        button.setDisabled(true);
        await this.plugin.generateRabbitHolesIndex(folderSettings);
        button.setButtonText("Generate Index");
        button.setDisabled(false);
      })
    );
  }
};

// src/services/AIService.ts
var import_obsidian2 = require("obsidian");
var AIServiceError = class extends Error {
  constructor(message, code, retryable = false, retryAfter) {
    super(message);
    this.code = code;
    this.retryable = retryable;
    this.retryAfter = retryAfter;
    this.name = "AIServiceError";
  }
};
var DEFAULT_RETRY_CONFIG = {
  maxRetries: 3,
  baseDelayMs: 1e3,
  maxDelayMs: 3e4
};
var AIService = class {
  constructor(settings, retryConfig) {
    this.settings = settings;
    this.retryConfig = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async testConnection() {
    try {
      const response = await this.generate('Say "connected" and nothing else.', "You are a helpful assistant.");
      return response.content.toLowerCase().includes("connected");
    } catch (error) {
      console.error("Connection test failed:", error);
      throw error;
    }
  }
  async generate(prompt, systemPrompt) {
    return this.executeWithRetry(async () => {
      const { endpoint, headers, body } = this.buildRequest(prompt, systemPrompt, false);
      console.log("Wonderland - Making request to:", endpoint);
      console.log("Wonderland - Using model:", body.model);
      try {
        const response = await (0, import_obsidian2.requestUrl)({
          url: endpoint,
          method: "POST",
          headers,
          body: JSON.stringify(body)
        });
        console.log("Wonderland - Response status:", response.status);
        if (response.status >= 400) {
          console.error("Wonderland - Error response:", response.json);
          throw this.parseErrorResponse(response.status, response.json);
        }
        return this.parseResponse(response.json);
      } catch (error) {
        if (this.isNetworkError(error)) {
          throw new AIServiceError(
            "Network error - please check your internet connection",
            "NETWORK_ERROR" /* NETWORK_ERROR */,
            true
          );
        }
        if (error instanceof AIServiceError) {
          throw error;
        }
        console.error("Wonderland - Request failed:", error);
        throw new AIServiceError(
          error instanceof Error ? error.message : "Unknown error occurred",
          "UNKNOWN" /* UNKNOWN */,
          false
        );
      }
    });
  }
  async generateStream(prompt, systemPrompt, onChunk, onComplete) {
    var _a;
    const { endpoint, headers, body } = this.buildRequest(prompt, systemPrompt, true);
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 12e4);
    try {
      const response = await fetch(endpoint, {
        method: "POST",
        headers,
        body: JSON.stringify(body),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        const errorBody = await response.json().catch(() => ({}));
        throw this.parseErrorResponse(response.status, errorBody);
      }
      const reader = (_a = response.body) == null ? void 0 : _a.getReader();
      if (!reader) {
        throw new AIServiceError("No response body", "UNKNOWN" /* UNKNOWN */, false);
      }
      const decoder = new TextDecoder();
      let buffer = "";
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            const chunk = this.parseStreamChunk(line);
            if (chunk) {
              if (chunk.done) {
                onComplete();
                return;
              }
              if (chunk.content) {
                onChunk(chunk.content);
              }
            }
          }
        }
        if (buffer) {
          const chunk = this.parseStreamChunk(buffer);
          if (chunk == null ? void 0 : chunk.content) {
            onChunk(chunk.content);
          }
        }
        onComplete();
      } finally {
        reader.releaseLock();
      }
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error && error.name === "AbortError") {
        throw new AIServiceError(
          "Request timed out - try with shorter content or check your connection",
          "TIMEOUT" /* TIMEOUT */,
          true
        );
      }
      if (error instanceof AIServiceError) {
        throw error;
      }
      if (this.isNetworkError(error)) {
        throw new AIServiceError(
          "Network error - please check your internet connection",
          "NETWORK_ERROR" /* NETWORK_ERROR */,
          true
        );
      }
      throw new AIServiceError(
        error instanceof Error ? error.message : "Unknown streaming error",
        "UNKNOWN" /* UNKNOWN */,
        false
      );
    }
  }
  async executeWithRetry(operation) {
    let lastError;
    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (error instanceof AIServiceError) {
          if (!error.retryable) {
            throw error;
          }
          if (attempt >= this.retryConfig.maxRetries) {
            throw error;
          }
          let delayMs = this.retryConfig.baseDelayMs * Math.pow(2, attempt);
          if (error.retryAfter) {
            delayMs = error.retryAfter * 1e3;
          }
          delayMs = Math.min(delayMs, this.retryConfig.maxDelayMs);
          console.log(`Wonderland - Retry attempt ${attempt + 1}/${this.retryConfig.maxRetries} after ${delayMs}ms delay`);
          await this.delay(delayMs);
        } else {
          throw error;
        }
      }
    }
    throw lastError || new AIServiceError("Retry limit exceeded", "UNKNOWN" /* UNKNOWN */, false);
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  isNetworkError(error) {
    if (error instanceof Error) {
      const networkErrorMessages = [
        "fetch failed",
        "network",
        "Failed to fetch",
        "NetworkError",
        "ECONNREFUSED",
        "ENOTFOUND",
        "ETIMEDOUT",
        "ECONNRESET",
        "ERR_NETWORK"
      ];
      return networkErrorMessages.some(
        (msg) => error.message.toLowerCase().includes(msg.toLowerCase()) || error.name.toLowerCase().includes(msg.toLowerCase())
      );
    }
    return false;
  }
  parseErrorResponse(status, body) {
    let message = "API request failed";
    let errorCode = "UNKNOWN" /* UNKNOWN */;
    let retryable = false;
    let retryAfter;
    const errorObj = body.error;
    if (errorObj == null ? void 0 : errorObj.message) {
      message = String(errorObj.message);
    } else if (body.message) {
      message = String(body.message);
    } else if (body.detail) {
      message = String(body.detail);
    }
    switch (status) {
      case 400:
        if (message.toLowerCase().includes("context") || message.toLowerCase().includes("token") || message.toLowerCase().includes("length")) {
          errorCode = "CONTEXT_LENGTH_EXCEEDED" /* CONTEXT_LENGTH_EXCEEDED */;
          message = "Content too long - try with shorter text or break it into smaller parts";
        }
        break;
      case 401:
        errorCode = "INVALID_API_KEY" /* INVALID_API_KEY */;
        message = "Invalid API key - please check your API key in settings";
        break;
      case 403:
        errorCode = "INVALID_API_KEY" /* INVALID_API_KEY */;
        message = "Access denied - your API key may not have the required permissions";
        break;
      case 404:
        errorCode = "MODEL_NOT_FOUND" /* MODEL_NOT_FOUND */;
        message = `Model not found - please check the model name in settings`;
        break;
      case 429:
        errorCode = "RATE_LIMIT" /* RATE_LIMIT */;
        retryable = true;
        if (message.toLowerCase().includes("quota") || message.toLowerCase().includes("billing") || message.toLowerCase().includes("limit exceeded")) {
          errorCode = "QUOTA_EXCEEDED" /* QUOTA_EXCEEDED */;
          message = "API quota exceeded - please check your billing/usage limits";
          retryable = false;
        } else {
          message = "Rate limit reached - waiting and retrying...";
          const retryMatch = message.match(/try again in (\d+)/i);
          if (retryMatch) {
            retryAfter = parseInt(retryMatch[1], 10);
          } else {
            retryAfter = 60;
          }
        }
        break;
      case 500:
      case 502:
      case 503:
      case 504:
        errorCode = "SERVER_ERROR" /* SERVER_ERROR */;
        retryable = true;
        message = `Server error (${status}) - the AI service may be experiencing issues. Retrying...`;
        retryAfter = 5;
        break;
      default:
        if (status >= 500) {
          errorCode = "SERVER_ERROR" /* SERVER_ERROR */;
          retryable = true;
        }
    }
    return new AIServiceError(message, errorCode, retryable, retryAfter);
  }
  buildRequest(prompt, systemPrompt, stream) {
    const provider = this.settings.aiProvider;
    switch (provider) {
      case "openai":
        return this.buildOpenAIRequest(prompt, systemPrompt, stream);
      case "anthropic":
        return this.buildAnthropicRequest(prompt, systemPrompt, stream);
      case "ollama":
        return this.buildOllamaRequest(prompt, systemPrompt, stream);
      case "custom":
        return this.buildCustomRequest(prompt, systemPrompt, stream);
      default:
        throw new AIServiceError(`Unknown provider: ${provider}`, "UNKNOWN" /* UNKNOWN */, false);
    }
  }
  buildOpenAIRequest(prompt, systemPrompt, stream) {
    const endpoint = PROVIDER_DEFAULTS.openai.endpoint;
    return {
      endpoint,
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.apiKey}`
      },
      body: {
        model: this.settings.model,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: prompt }
        ],
        max_tokens: this.settings.maxTokens,
        temperature: this.settings.temperature,
        stream
      }
    };
  }
  buildAnthropicRequest(prompt, systemPrompt, stream) {
    const endpoint = PROVIDER_DEFAULTS.anthropic.endpoint;
    return {
      endpoint,
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.settings.apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: {
        model: this.settings.model,
        system: systemPrompt,
        messages: [
          { role: "user", content: prompt }
        ],
        max_tokens: this.settings.maxTokens,
        temperature: this.settings.temperature,
        stream
      }
    };
  }
  buildOllamaRequest(prompt, systemPrompt, stream) {
    return {
      endpoint: this.settings.apiEndpoint || PROVIDER_DEFAULTS.ollama.endpoint,
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        model: this.settings.model,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: prompt }
        ],
        stream,
        options: {
          temperature: this.settings.temperature,
          num_predict: this.settings.maxTokens
        }
      }
    };
  }
  buildCustomRequest(prompt, systemPrompt, stream) {
    return {
      endpoint: this.settings.apiEndpoint,
      headers: {
        "Content-Type": "application/json",
        ...this.settings.apiKey ? { "Authorization": `Bearer ${this.settings.apiKey}` } : {}
      },
      body: {
        model: this.settings.model,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: prompt }
        ],
        max_tokens: this.settings.maxTokens,
        temperature: this.settings.temperature,
        stream
      }
    };
  }
  parseResponse(json) {
    var _a, _b, _c;
    const provider = this.settings.aiProvider;
    switch (provider) {
      case "anthropic": {
        const content = json.content;
        return {
          content: ((_a = content == null ? void 0 : content[0]) == null ? void 0 : _a.text) || "",
          model: json.model,
          usage: json.usage ? {
            promptTokens: json.usage.input_tokens,
            completionTokens: json.usage.output_tokens
          } : void 0
        };
      }
      case "ollama": {
        const message = json.message;
        return {
          content: (message == null ? void 0 : message.content) || "",
          model: json.model
        };
      }
      case "openai":
      case "custom":
      default: {
        const choices = json.choices;
        return {
          content: ((_c = (_b = choices == null ? void 0 : choices[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || "",
          model: json.model,
          usage: json.usage ? {
            promptTokens: json.usage.prompt_tokens,
            completionTokens: json.usage.completion_tokens
          } : void 0
        };
      }
    }
  }
  parseStreamChunk(line) {
    var _a;
    const trimmed = line.trim();
    if (!trimmed || trimmed === "data: [DONE]") {
      return trimmed === "data: [DONE]" ? { content: "", done: true } : null;
    }
    const provider = this.settings.aiProvider;
    try {
      let data;
      if (trimmed.startsWith("data: ")) {
        data = JSON.parse(trimmed.slice(6));
      } else if (trimmed.startsWith("{")) {
        data = JSON.parse(trimmed);
      } else {
        return null;
      }
      switch (provider) {
        case "anthropic": {
          if (data.type === "content_block_delta") {
            const delta = data.delta;
            return { content: (delta == null ? void 0 : delta.text) || "", done: false };
          }
          if (data.type === "message_stop") {
            return { content: "", done: true };
          }
          return null;
        }
        case "ollama": {
          const message = data.message;
          const done = data.done;
          return {
            content: (message == null ? void 0 : message.content) || "",
            done: done || false
          };
        }
        case "openai":
        case "custom":
        default: {
          const choices = data.choices;
          if (!choices || choices.length === 0)
            return null;
          const choice = choices[0];
          if (choice.finish_reason === "stop") {
            return { content: "", done: true };
          }
          return {
            content: ((_a = choice.delta) == null ? void 0 : _a.content) || "",
            done: false
          };
        }
      }
    } catch (e) {
      return null;
    }
  }
  // Utility method to get user-friendly error message
  static getUserFriendlyError(error) {
    if (error instanceof AIServiceError) {
      return error.message;
    }
    if (error instanceof Error) {
      const message = error.message;
      if (message.includes("fetch failed") || message.includes("Failed to fetch")) {
        return "Network error - please check your internet connection";
      }
      if (message.includes("timeout") || message.includes("Timeout")) {
        return "Request timed out - try again or check your connection";
      }
      return message;
    }
    return "An unexpected error occurred";
  }
};

// src/prompts/evergreenNote.ts
var EVERGREEN_NOTE_SYSTEM_PROMPT = `You are an expert at creating Evergreen Notes following Andy Matuschak's methodology.

PRINCIPLES:
1. ATOMIC: Each note addresses ONE concept fully
2. CONCEPT-ORIENTED: Title should be a clear concept statement, not a question
3. DENSELY LINKED: Include [[wikilinks]] to related concepts that deserve their own notes
4. PERSONAL VOICE: Write as if explaining to yourself, but publishable

FORMATTING:
- Start with a clear, direct statement of the concept
- Use short paragraphs (2-4 sentences each)
- Include [[placeholder links]] for concepts that deserve separate notes
- These linked concepts should be ATOMIC ideas, not just keywords
- End with connections to broader themes if relevant

PLACEHOLDER LINKS:
- Create [[links]] to concepts that are substantial enough for their own note
- Choose concept-oriented names (e.g., [[Spaced repetition enhances long-term memory]] not [[spaced repetition]])
- Aim for 3-7 meaningful links per note
- Only link concepts that would genuinely benefit from deeper exploration
- IMPORTANT: Link text should be a complete concept statement

OUTPUT FORMAT:
Return ONLY the note content in Markdown. No meta-commentary, no titles (title will be added separately).`;
var EVERGREEN_NOTE_USER_PROMPT = (prompt, context, existingNotes) => {
  let userPrompt = `Create an evergreen note answering this prompt:

"${prompt}"`;
  if (context) {
    userPrompt += `

Relevant context from existing notes:
${context}`;
  }
  if (existingNotes.length > 0) {
    userPrompt += `

These notes already exist in the knowledge base (you can link to them with [[Note Title]]):
${existingNotes.map((n) => `- ${n}`).join("\n")}`;
  }
  userPrompt += `

Remember: Include [[placeholder links]] for concepts that deserve their own atomic notes. Make link text concept-oriented statements.`;
  return userPrompt;
};
var TITLE_GENERATION_PROMPT = `Based on the following note content, generate a concise, concept-oriented title.

RULES:
- Title should be a statement or concept, not a question
- Keep it under 60 characters
- Make it specific and descriptive
- It should work as a "API" for the concept - others should understand what the note is about from the title alone

Return ONLY the title, nothing else.

Content:
`;
var RABBIT_HOLE_QUESTIONS_PROMPT = `Based on the following note content, generate 3-4 intriguing concept statements that invite the reader to go deeper down the rabbit hole of knowledge.

GUIDELINES:
- Statements should open new avenues of inquiry, not just rehash the content
- Frame as declarative concepts to explore: "The relationship between X and Y", "How X influences Y", "The hidden connection of X to Z"
- Statements should feel exciting to explore - like doorways to new wonderlands
- Each statement will become a clickable link that generates its own note
- IMPORTANT: Do NOT use question marks (?) - these will become note titles
- Keep statements concise but intriguing (under 60 characters)

FORMAT:
Return ONLY a markdown list where each statement is wrapped in [[double brackets]] to make it a wiki-link:
- [[The trainability of time perception]]
- [[How dreams shape memory formation]]
- [[The reward mechanism behind curiosity]]
- [[Connections between sleep and creativity]]

Note content:
`;
var CLASSIFY_NOTE_PROMPT = `You are classifying a new note into the most appropriate existing subfolder in a knowledge base.

TASK:
Given a note title and content, and a list of existing subfolders with their contents, determine which subfolder this note belongs in.

GUIDELINES:
- Choose the subfolder where this note fits most naturally
- Consider thematic similarity with other notes in each folder
- If no folder is a good fit, respond with "uncategorized"
- Only respond with the folder name, nothing else

Existing subfolders and their notes:
`;
var ORGANIZE_FOLDER_PROMPT = `You are organizing a knowledge base into intuitive subfolders. Given a list of note titles, suggest how to organize them into thematic subfolders.

GUIDELINES:
- Create 3-7 subfolders maximum
- Folder names should be broad themes, not specific topics
- Each folder should have a clear, intuitive purpose
- Some notes may fit multiple categories - choose the best fit
- Use simple, lowercase folder names (e.g., "science", "philosophy", "creativity")

OUTPUT FORMAT:
Return a JSON object where keys are folder names and values are arrays of note filenames to move there.
Example:
{
  "science": ["How neurons fire.md", "Quantum mechanics basics.md"],
  "philosophy": ["What is consciousness.md", "Free will debate.md"],
  "uncategorized": ["Random thought.md"]
}

Notes to organize:
`;
var UPDATE_NOTE_APPEND_PROMPT = `You are adding new insights to an existing note from related notes in the knowledge base.

TASK:
- Review the current note content and the related notes
- Create a new "## New discoveries" section with fresh insights
- Add connections, perspectives, or elaborations from related notes
- Include [[links]] to source notes and new concepts

GUIDELINES:
- DO NOT modify or repeat the existing content
- ONLY output the new section to append (starting with "## New discoveries")
- Keep it concise (3-5 bullet points or short paragraphs)
- Link to source notes when referencing their insights

Current note content:
`;
var UPDATE_NOTE_INTEGRATE_PROMPT = `You are seamlessly integrating new insights into an existing note from related notes in the knowledge base.

TASK:
- Review the current note content and the related notes
- Rewrite the note to naturally incorporate new insights
- Weave in connections and perspectives from related notes
- Add [[links]] to related concepts where appropriate
- Maintain the original voice and structure

GUIDELINES:
- Preserve all original content and meaning
- Integrate new insights smoothly into existing paragraphs
- Add new paragraphs only if needed for substantial additions
- Link to source notes when adding their insights
- The result should read as one cohesive, enriched note

Current note content:
`;
var RABBIT_HOLES_INDEX_PROMPT = `You are generating a "Rabbit Holes" index that shows all the unexplored paths in a knowledge wonderland.

TASK:
Create a well-organized document listing all unresolved links (notes waiting to be created).

GUIDELINES:
- Group related unresolved links into thematic sections
- Add brief context about what each link might explore
- Use encouraging language - these are exciting rabbit holes to explore!
- Sort by relevance or thematic connection, not alphabetically

FORMAT:
Return markdown with sections. Example:

## \u{1F573}\uFE0F Deep Rabbit Holes
These fundamental ideas anchor the wonderland:
- [[The nature of consciousness]] - A deep exploration awaiting
- [[Memory formation mechanisms]] - Neural pathways to discover

## \u{1F430} Quick Explorations
Shorter paths worth exploring:
- [[Creative problem solving techniques]]
- [[The role of sleep in learning]]

## \u{1F517} Connections to Make
Links between existing ideas:
- [[How motivation affects memory]]

Unresolved links to organize:
`;
var CUSTOM_INSTRUCTIONS_WRAPPER = (customInstructions, basePrompt) => {
  if (!customInstructions || customInstructions.trim() === "") {
    return basePrompt;
  }
  return `${basePrompt}

SPECIAL INSTRUCTIONS FOR THIS WONDERLAND:
${customInstructions}

Apply these special instructions while following the base guidelines above.`;
};
var FOLDER_GOAL_PROMPTS = {
  learn: `LEARNING FOCUS: Generate content optimized for understanding and retention. Include clear explanations, examples, and connections to foundational concepts. Use analogies when helpful. Structure content to build understanding progressively.`,
  action: `ACTION-ORIENTED FOCUS: Generate practical, actionable content. Include step-by-step guides, checklists, and concrete next steps. Focus on "how to" and "what to do next." Prioritize implementation over theory.`,
  reflect: `CRITICAL REFLECTION FOCUS: Generate content that encourages deep thinking and analysis. Include multiple perspectives, counterarguments, and thought-provoking questions. Challenge assumptions and explore nuances.`,
  research: `RESEARCH FOCUS: Generate well-structured, evidence-based content. Include citations-style references where appropriate, methodological considerations, and connections to broader academic discourse. Note limitations and areas for further investigation.`,
  creative: `CREATIVE EXPLORATION FOCUS: Generate content that sparks imagination and novel connections. Include unconventional perspectives, metaphors, and cross-domain links. Encourage experimentation and "what if" thinking.`,
  custom: ""
  // Will use customGoalDescription
};
var FOLDER_GOAL_WRAPPER = (folderGoal, customGoalDescription, basePrompt) => {
  let goalPrompt = FOLDER_GOAL_PROMPTS[folderGoal] || "";
  if (folderGoal === "custom" && customGoalDescription) {
    goalPrompt = `CUSTOM FOCUS: ${customGoalDescription}`;
  }
  if (!goalPrompt) {
    return basePrompt;
  }
  return `${basePrompt}

${goalPrompt}`;
};
var EXTERNAL_LINKS_PROMPT = (maxLinks) => `

EXTERNAL REFERENCES:
Include up to ${maxLinks} external reference links to reputable sources that would help the reader learn more. Format these as a "## References" section at the end with markdown links:
- [Source Title](https://example.com) - Brief description

Choose authoritative sources like Wikipedia, academic institutions, or well-known publications. Only include links you're confident would be helpful.`;
var PERSONALIZED_SUGGESTIONS_PROMPT = (userInterests) => `

PERSONALIZED FOCUS:
The user is particularly interested in: ${userInterests}

When generating "Down the rabbit hole" suggestions and links, prioritize connections that relate to these interests. Look for unexpected intersections between the current topic and the user's areas of interest.`;

// src/prompts/placeholderNote.ts
var PLACEHOLDER_NOTE_SYSTEM_PROMPT = `You are creating an Evergreen Note for a concept that was linked from another note.

CONTEXT:
- This concept was mentioned in another note as worthy of deeper exploration
- You'll receive the concept name and the context where it was mentioned
- Create a complete, atomic note that fully explores this single concept

PRINCIPLES:
1. ATOMIC: Focus entirely on this one concept
2. COMPLETE: Provide a thorough exploration, not just a definition
3. LINKED: Include [[placeholder links]] to related concepts
4. STANDALONE: The note should make sense on its own

GUIDELINES:
- Start with a clear explanation of the concept
- Include examples, implications, or applications where relevant
- Add connections to related ideas via [[links]]
- Don't repeat information from the source note verbatim
- Add new insights, perspectives, or nuances

OUTPUT: Return ONLY the Markdown note content. No title, no meta-commentary.`;
var PLACEHOLDER_NOTE_USER_PROMPT = (concept, sourceContext, sourceNoteName, relatedNotes) => {
  let prompt = `Create an evergreen note for the concept: "${concept}"

This concept was mentioned in "${sourceNoteName}" in the following context:
"${sourceContext}"`;
  if (relatedNotes.length > 0) {
    prompt += `

Related notes in the knowledge base you can link to:
${relatedNotes.map((n) => `- ${n}`).join("\n")}`;
  }
  prompt += `

Create a complete, atomic note exploring this concept. Include appropriate [[placeholder links]] to other concepts that deserve their own notes.`;
  return prompt;
};

// src/main.ts
var EvergreenAIPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    // Track notes created from clicking unresolved links: maps new file path -> source Wonderland folder path
    this.pendingGenerations = /* @__PURE__ */ new Map();
    // Track the last active Wonderland folder (for when files are created from link clicks)
    this.lastActiveWonderlandFolder = null;
    // Intervals for auto-organization (per folder)
    this.organizeIntervals = /* @__PURE__ */ new Map();
    // Intervals for auto-update (per folder)
    this.autoUpdateIntervals = /* @__PURE__ */ new Map();
  }
  // ============================================
  // FOLDER DETECTION & SETTINGS HELPERS
  // ============================================
  // Get all configured Wonderland folder paths
  get wonderlandPaths() {
    return this.settings.wonderlandFolders.map((f) => f.path);
  }
  // Check if a file path is within any Wonderland folder
  isInWonderland(filePath) {
    return this.settings.wonderlandFolders.some(
      (folder) => filePath === folder.path || filePath.startsWith(folder.path + "/")
    );
  }
  // Get the Wonderland folder settings for a given file path
  getWonderlandSettingsFor(filePath) {
    return this.settings.wonderlandFolders.find(
      (folder) => filePath === folder.path || filePath.startsWith(folder.path + "/")
    ) || null;
  }
  // Get the Wonderland folder path that contains a file
  getWonderlandFolderFor(filePath) {
    const settings = this.getWonderlandSettingsFor(filePath);
    return (settings == null ? void 0 : settings.path) || null;
  }
  // Get the currently selected folder settings (for settings UI)
  get selectedFolderSettings() {
    const index = this.settings.selectedFolderIndex;
    return this.settings.wonderlandFolders[index] || null;
  }
  // Check if a filename is "Untitled" or equivalent (should not auto-generate)
  isUntitledNote(filename) {
    const untitledPatterns = [
      /^untitled$/i,
      /^untitled \d+$/i,
      /^new note$/i,
      /^new note \d+$/i,
      /^note$/i,
      /^note \d+$/i
    ];
    const baseName = filename.replace(/\.md$/, "");
    return untitledPatterns.some((pattern) => pattern.test(baseName));
  }
  // Get the rabbit holes index name for a folder
  getRabbitHolesIndexName(folderPath) {
    const folderName = folderPath.split("/").pop() || "Wonderland";
    return `${folderName} Rabbit Holes`;
  }
  // Handle folder renames - update Wonderland folder paths in settings
  async handleFolderRename(oldPath, newPath) {
    let updated = false;
    for (const folder of this.settings.wonderlandFolders) {
      if (folder.path === oldPath) {
        console.log(`Wonderland - Folder renamed from ${oldPath} to ${newPath}`);
        folder.path = newPath;
        updated = true;
      }
    }
    if (updated) {
      await this.saveSettings();
      new import_obsidian3.Notice(`Wonderland folder path updated: ${newPath}`);
    }
  }
  // Get the current folder path from the active file
  getCurrentFolderPath() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return null;
    const parent = activeFile.parent;
    return (parent == null ? void 0 : parent.path) || null;
  }
  async onload() {
    await this.loadSettings();
    this.aiService = new AIService(this.settings);
    this.addRibbonIcon("rabbit", "Enter Wonderland", () => {
      this.openPromptModal();
    });
    this.addCommand({
      id: "enter-wonderland",
      name: "Enter Wonderland - explore a topic",
      callback: () => {
        this.openPromptModal();
      }
    });
    this.addCommand({
      id: "explore-selection",
      name: "Go down the rabbit hole with selection",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          this.generateNoteFromPrompt(selection);
        } else {
          new import_obsidian3.Notice("Please select some text first");
        }
      }
    });
    this.addCommand({
      id: "explore-current-note",
      name: "Explore this note (generate content from title)",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          new import_obsidian3.Notice("No active note");
          return;
        }
        const folderSettings = this.getWonderlandSettingsFor(activeFile.path);
        if (!folderSettings) {
          new import_obsidian3.Notice("This note is not in a Wonderland folder");
          return;
        }
        await this.generateContentForNote(activeFile, folderSettings);
      }
    });
    this.addCommand({
      id: "enrich-note",
      name: "Enrich note with Wonderland knowledge",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          new import_obsidian3.Notice("No active note");
          return;
        }
        const folderSettings = this.getWonderlandSettingsFor(activeFile.path);
        if (!folderSettings) {
          new import_obsidian3.Notice("This note is not in a Wonderland folder");
          return;
        }
        await this.enrichNoteWithKnowledge(activeFile, folderSettings);
      }
    });
    this.addCommand({
      id: "organize-wonderland",
      name: "Organize current Wonderland into subfolders",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          new import_obsidian3.Notice("No active note - open a note in a Wonderland folder first");
          return;
        }
        const folderSettings = this.getWonderlandSettingsFor(activeFile.path);
        if (!folderSettings) {
          new import_obsidian3.Notice("This note is not in a Wonderland folder");
          return;
        }
        await this.organizeWonderlandFolder(folderSettings);
      }
    });
    this.addCommand({
      id: "generate-rabbit-holes",
      name: "Generate Rabbit Holes index (show unresolved links)",
      callback: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          new import_obsidian3.Notice("No active note - open a note in a Wonderland folder first");
          return;
        }
        const folderSettings = this.getWonderlandSettingsFor(activeFile.path);
        if (!folderSettings) {
          new import_obsidian3.Notice("This note is not in a Wonderland folder");
          return;
        }
        await this.generateRabbitHolesIndex(folderSettings);
      }
    });
    this.registerDomEvent(document, "click", async (evt) => {
      await this.handleLinkClick(evt);
    }, { capture: true });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          const wonderlandFolder = this.getWonderlandFolderFor(activeFile.path);
          if (wonderlandFolder) {
            this.lastActiveWonderlandFolder = wonderlandFolder;
            console.log("Wonderland - Active folder tracked:", wonderlandFolder);
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (file instanceof import_obsidian3.TFile && file.extension === "md") {
          const sourceFolder = this.lastActiveWonderlandFolder;
          try {
            const content = await this.app.vault.read(file);
            if (content.trim() === "" && sourceFolder) {
              console.log("Wonderland - New empty file created:", file.path, "from Wonderland:", sourceFolder);
              this.pendingGenerations.set(file.path, sourceFolder);
            }
          } catch (e) {
            setTimeout(async () => {
              try {
                const content = await this.app.vault.read(file);
                if (content.trim() === "" && sourceFolder) {
                  console.log("Wonderland - New empty file created (delayed):", file.path, "from Wonderland:", sourceFolder);
                  this.pendingGenerations.set(file.path, sourceFolder);
                }
              } catch (e2) {
              }
            }, 50);
          }
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", async (file) => {
        if (file) {
          setTimeout(async () => {
            await this.handleFileOpen(file);
          }, 150);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        if (file instanceof import_obsidian3.TFolder) {
          await this.handleFolderRename(oldPath, file.path);
        }
        for (const folder of this.settings.wonderlandFolders) {
          if (folder.path.startsWith(oldPath + "/")) {
            const newFolderPath = folder.path.replace(oldPath, file.path);
            console.log(`Wonderland - Parent folder renamed, updating ${folder.path} to ${newFolderPath}`);
            folder.path = newFolderPath;
            await this.saveSettings();
          }
        }
      })
    );
    this.addSettingTab(new EvergreenAISettingTab(this.app, this));
    this.setupAllIntervals();
    if (!this.settings.hasShownWelcome) {
      setTimeout(() => {
        new WelcomeModal(this.app, this, async () => {
          this.settings.hasShownWelcome = true;
          await this.saveSettings();
        }).open();
      }, 500);
    }
    console.log("Wonderland plugin loaded - ready to explore");
  }
  onunload() {
    for (const interval of this.organizeIntervals.values()) {
      window.clearInterval(interval);
    }
    for (const interval of this.autoUpdateIntervals.values()) {
      window.clearInterval(interval);
    }
    console.log("Wonderland plugin unloaded");
  }
  // Set up intervals for all configured folders
  setupAllIntervals() {
    for (const interval of this.organizeIntervals.values()) {
      window.clearInterval(interval);
    }
    for (const interval of this.autoUpdateIntervals.values()) {
      window.clearInterval(interval);
    }
    this.organizeIntervals.clear();
    this.autoUpdateIntervals.clear();
    for (const folder of this.settings.wonderlandFolders) {
      this.setupFolderIntervals(folder);
    }
  }
  setupFolderIntervals(folder) {
    if (folder.organizeOnInterval && folder.autoOrganize) {
      const intervalMs = folder.organizeIntervalMinutes * 60 * 1e3;
      const intervalId = window.setInterval(async () => {
        console.log(`Wonderland - Running scheduled organization for ${folder.path}`);
        await this.organizeWonderlandFolder(folder, true);
      }, intervalMs);
      this.organizeIntervals.set(folder.path, intervalId);
      console.log(`Wonderland - Auto-organize scheduled every ${folder.organizeIntervalMinutes} minutes for ${folder.path}`);
    }
    if (folder.autoUpdateNotes) {
      const intervalMs = folder.autoUpdateIntervalMinutes * 60 * 1e3;
      const intervalId = window.setInterval(async () => {
        console.log(`Wonderland - Running scheduled auto-update for ${folder.path}`);
        await this.autoUpdateFolderNotes(folder, true);
      }, intervalMs);
      this.autoUpdateIntervals.set(folder.path, intervalId);
      console.log(`Wonderland - Auto-update scheduled every ${folder.autoUpdateIntervalMinutes} minutes for ${folder.path}`);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    var _a;
    await this.saveData(this.settings);
    (_a = this.aiService) == null ? void 0 : _a.updateSettings(this.settings);
    this.setupAllIntervals();
  }
  openPromptModal() {
    if (this.settings.wonderlandFolders.length === 0) {
      new import_obsidian3.Notice("Please add a Wonderland folder in settings first");
      return;
    }
    new PromptModal(this.app, this, async (prompt, folderPath) => {
      await this.generateNoteFromPrompt(prompt, folderPath);
    }).open();
  }
  async generateNoteFromPrompt(prompt, targetFolderPath) {
    if (!this.validateSettings())
      return;
    const folderSettings = targetFolderPath ? this.settings.wonderlandFolders.find((f) => f.path === targetFolderPath) : this.settings.wonderlandFolders[0];
    if (!folderSettings) {
      new import_obsidian3.Notice("No Wonderland folder configured");
      return;
    }
    const notice = new import_obsidian3.Notice("Entering wonderland...", 0);
    try {
      const existingNotes = this.getExistingNoteTitles(folderSettings.path);
      let systemPrompt = EVERGREEN_NOTE_SYSTEM_PROMPT;
      if (folderSettings.folderGoal) {
        systemPrompt = FOLDER_GOAL_WRAPPER(
          folderSettings.folderGoal,
          folderSettings.customGoalDescription || "",
          systemPrompt
        );
      }
      if (folderSettings.customInstructions) {
        systemPrompt = CUSTOM_INSTRUCTIONS_WRAPPER(folderSettings.customInstructions, systemPrompt);
      }
      if (folderSettings.includeExternalLinks) {
        systemPrompt += EXTERNAL_LINKS_PROMPT(folderSettings.maxExternalLinks || 3);
      }
      const userPrompt = EVERGREEN_NOTE_USER_PROMPT(prompt, "", existingNotes);
      const response = await this.aiService.generate(userPrompt, systemPrompt);
      const content = response.content;
      const title = await this.generateTitle(content);
      const filePath = await this.saveNote(title, "", folderSettings);
      const formattedContent = await this.formatNote(content, folderSettings, prompt, void 0, true, filePath);
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian3.TFile) {
        await this.app.vault.modify(file, formattedContent);
      }
      notice.hide();
      new import_obsidian3.Notice(`Created: ${title}`);
      if (file instanceof import_obsidian3.TFile) {
        await this.app.workspace.getLeaf().openFile(file);
      }
    } catch (error) {
      notice.hide();
      console.error("Error generating note:", error);
      new import_obsidian3.Notice(`Error: ${AIService.getUserFriendlyError(error)}`);
    }
  }
  async handleLinkClick(evt) {
    var _a, _b;
    const target = evt.target;
    console.log("Wonderland - Click detected on:", target.tagName, target.className);
    let linkText = null;
    let linkElement = target.closest(".internal-link");
    if (linkElement) {
      linkText = linkElement.getAttribute("data-href");
      console.log("Wonderland - Found internal-link, href:", linkText);
    }
    if (!linkText) {
      const cmLink = target.closest(".cm-hmd-internal-link, .cm-link, .cm-underline");
      if (cmLink) {
        const lineEl = target.closest(".cm-line");
        if (lineEl) {
          const lineText = lineEl.textContent || "";
          console.log("Wonderland - Line text:", lineText);
          const linkMatches = lineText.match(/\[\[([^\]]+)\]\]/g);
          console.log("Wonderland - Link matches:", linkMatches);
          if (linkMatches && linkMatches.length > 0) {
            let clickedText = target.textContent || "";
            let parent = target.parentElement;
            while (parent && parent.classList.contains("cm-line") === false) {
              if (parent.classList.contains("cm-hmd-internal-link") || ((_a = parent.textContent) == null ? void 0 : _a.includes("[["))) {
                const siblings = (_b = parent.parentElement) == null ? void 0 : _b.children;
                if (siblings) {
                  let fullText = "";
                  for (let i = 0; i < siblings.length; i++) {
                    fullText += siblings[i].textContent || "";
                  }
                  if (fullText.includes("[[") && fullText.includes("]]")) {
                    const match = fullText.match(/\[\[([^\]]+)\]\]/);
                    if (match) {
                      clickedText = match[1].split("|")[0];
                      break;
                    }
                  }
                }
              }
              parent = parent.parentElement;
            }
            console.log("Wonderland - Clicked text:", clickedText);
            for (const match of linkMatches) {
              const innerText = match.slice(2, -2);
              const linkName = innerText.split("|")[0];
              if (linkName === clickedText || innerText === clickedText || linkName.includes(clickedText) || clickedText.includes(linkName) || innerText.includes(clickedText)) {
                linkText = linkName;
                console.log("Wonderland - Matched link:", linkText);
                break;
              }
            }
            if (!linkText && linkMatches.length === 1) {
              linkText = linkMatches[0].slice(2, -2).split("|")[0];
              console.log("Wonderland - Using single link on line:", linkText);
            }
          }
        }
      }
    }
    if (!linkText) {
      console.log("Wonderland - Could not find link text, ignoring");
      return;
    }
    const linkedFile = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
    console.log("Wonderland - Linked file exists:", !!linkedFile);
    if (linkedFile)
      return;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    const folderSettings = this.getWonderlandSettingsFor(activeFile.path);
    if (!folderSettings) {
      console.log("Wonderland - Source note not in a Wonderland folder, ignoring");
      return;
    }
    if (!folderSettings.autoGeneratePlaceholders) {
      console.log("Wonderland - Auto-generation disabled for this folder");
      return;
    }
    console.log("Wonderland - Intercepting placeholder link click for:", linkText);
    evt.preventDefault();
    evt.stopPropagation();
    if (!this.validateSettings())
      return;
    const notice = new import_obsidian3.Notice(`Generating: ${linkText}...`, 0);
    try {
      const sourceContext = await this.getSourceContext(linkText, activeFile);
      const relatedNotes = this.getExistingNoteTitles(folderSettings.path);
      const userPrompt = PLACEHOLDER_NOTE_USER_PROMPT(
        linkText,
        sourceContext,
        activeFile.basename,
        relatedNotes
      );
      const filePath = await this.getAvailableFilePath(linkText, folderSettings.path);
      await this.ensureFolderExists(folderSettings.path);
      const initialContent = await this.formatNote("*Drafting...*\n\n", folderSettings, void 0, linkText, false);
      await this.app.vault.create(filePath, initialContent);
      const newFile = this.app.vault.getAbstractFileByPath(filePath);
      if (newFile instanceof import_obsidian3.TFile) {
        const leaf = this.app.workspace.getLeaf();
        await leaf.openFile(newFile);
        const response = await this.aiService.generate(userPrompt, PLACEHOLDER_NOTE_SYSTEM_PROMPT);
        const content = response.content;
        const formattedContent = await this.formatNote(content, folderSettings, void 0, linkText);
        await this.app.vault.modify(newFile, formattedContent);
        if (folderSettings.autoClassifyNewNotes) {
          const classifiedFolder = await this.classifyNoteIntoFolder(linkText, content, folderSettings);
          if (classifiedFolder && classifiedFolder !== "uncategorized") {
            const newFolderPath = `${folderSettings.path}/${classifiedFolder}`;
            await this.ensureFolderExists(newFolderPath);
            const newFilePath = `${newFolderPath}/${newFile.name}`;
            try {
              await this.app.fileManager.renameFile(newFile, newFilePath);
              console.log(`Wonderland - Moved note to: ${classifiedFolder}`);
            } catch (e) {
              console.error("Wonderland - Failed to move note:", e);
            }
          }
        }
      }
      notice.hide();
      new import_obsidian3.Notice(`Created: ${linkText}`);
    } catch (error) {
      notice.hide();
      console.error("Error generating placeholder note:", error);
      new import_obsidian3.Notice(`Error: ${AIService.getUserFriendlyError(error)}`);
    }
  }
  async enrichNoteWithKnowledge(file, folderSettings, silent = false) {
    if (!this.validateSettings())
      return false;
    const title = file.basename;
    const notice = silent ? null : new import_obsidian3.Notice(`Enriching ${title} with Wonderland knowledge...`, 0);
    try {
      const currentContent = await this.app.vault.read(file);
      const relatedNotes = await this.getRelatedWonderlandNotes(file, folderSettings);
      if (relatedNotes.length === 0) {
        if (notice)
          notice.hide();
        if (!silent)
          new import_obsidian3.Notice("No related notes found in Wonderland to enrich from");
        return false;
      }
      const relatedContext = relatedNotes.map((n) => `### ${n.title}
${n.content.substring(0, 500)}...`).join("\n\n");
      const promptTemplate = folderSettings.autoUpdateMode === "integrate" ? UPDATE_NOTE_INTEGRATE_PROMPT : UPDATE_NOTE_APPEND_PROMPT;
      const prompt = promptTemplate + currentContent + "\n\n---\n\nRelated notes from Wonderland:\n\n" + relatedContext;
      const response = await this.aiService.generate(
        prompt,
        "You are a knowledge synthesizer, weaving connections between ideas in a wonderland of knowledge."
      );
      if (folderSettings.autoUpdateMode === "integrate") {
        await this.app.vault.modify(file, response.content);
      } else {
        const newContent = currentContent.trim() + "\n\n" + response.content.trim();
        await this.app.vault.modify(file, newContent);
      }
      if (notice)
        notice.hide();
      if (!silent)
        new import_obsidian3.Notice(`Enriched: ${title}`);
      return true;
    } catch (error) {
      if (notice)
        notice.hide();
      console.error("Error enriching note:", error);
      if (!silent)
        new import_obsidian3.Notice(`Error: ${AIService.getUserFriendlyError(error)}`);
      return false;
    }
  }
  async autoUpdateFolderNotes(folderSettings, silent = false) {
    if (!this.validateSettings())
      return;
    const notice = silent ? null : new import_obsidian3.Notice(`Auto-updating notes in ${folderSettings.path}...`, 0);
    let updatedCount = 0;
    try {
      const allFolderFiles = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(folderSettings.path + "/") || f.path === folderSettings.path);
      const filesToUpdate = allFolderFiles.slice(0, 10);
      for (const file of filesToUpdate) {
        const updated = await this.enrichNoteWithKnowledge(file, folderSettings, true);
        if (updated)
          updatedCount++;
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      if (notice)
        notice.hide();
      if (!silent)
        new import_obsidian3.Notice(`Updated ${updatedCount} notes in ${folderSettings.path}`);
    } catch (error) {
      if (notice)
        notice.hide();
      console.error("Error in auto-update:", error);
      if (!silent)
        new import_obsidian3.Notice(`Error: ${AIService.getUserFriendlyError(error)}`);
    }
  }
  async getRelatedWonderlandNotes(currentFile, folderSettings) {
    const files = this.app.vault.getMarkdownFiles().filter(
      (f) => (f.path.startsWith(folderSettings.path + "/") || f.path === folderSettings.path) && f.path !== currentFile.path
    );
    const currentContent = await this.app.vault.read(currentFile);
    const currentTitle = currentFile.basename.toLowerCase();
    const scoredFiles = [];
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const fileTitle = file.basename.toLowerCase();
      let score = 0;
      if (currentContent.toLowerCase().includes(fileTitle))
        score += 3;
      if (content.toLowerCase().includes(currentTitle))
        score += 3;
      const currentLinks = currentContent.match(/\[\[([^\]]+)\]\]/g) || [];
      const fileLinks = content.match(/\[\[([^\]]+)\]\]/g) || [];
      const sharedLinks = currentLinks.filter((l) => fileLinks.includes(l));
      score += sharedLinks.length;
      if (score > 0) {
        scoredFiles.push({ file, score });
      }
    }
    scoredFiles.sort((a, b) => b.score - a.score);
    const topFiles = scoredFiles.slice(0, 5);
    const results = [];
    for (const { file } of topFiles) {
      const content = await this.app.vault.read(file);
      results.push({ title: file.basename, content });
    }
    return results;
  }
  async organizeWonderlandFolder(folderSettings, silent = false) {
    if (!this.validateSettings())
      return;
    const notice = silent ? null : new import_obsidian3.Notice(`Organizing ${folderSettings.path}...`, 0);
    try {
      const allFiles = this.app.vault.getMarkdownFiles().filter((f) => {
        if (!f.path.startsWith(folderSettings.path + "/"))
          return false;
        const relativePath = f.path.replace(folderSettings.path + "/", "");
        return !relativePath.includes("/");
      });
      if (allFiles.length < 3) {
        if (notice)
          notice.hide();
        if (!silent)
          new import_obsidian3.Notice("Not enough notes to organize (need at least 3)");
        return;
      }
      const fileTitles = allFiles.map((f) => f.name);
      const prompt = ORGANIZE_FOLDER_PROMPT + fileTitles.join("\n");
      const response = await this.aiService.generate(
        prompt,
        "You are a librarian organizing a collection of knowledge into intuitive categories."
      );
      let organization;
      try {
        const jsonMatch = response.content.match(/\{[\s\S]*\}/);
        if (!jsonMatch)
          throw new Error("No JSON found in response");
        organization = JSON.parse(jsonMatch[0]);
      } catch (e) {
        console.error("Failed to parse organization response:", response.content);
        if (notice)
          notice.hide();
        if (!silent)
          new import_obsidian3.Notice("Failed to parse organization suggestions");
        return;
      }
      let movedCount = 0;
      for (const [folder, files] of Object.entries(organization)) {
        if (folder === "uncategorized")
          continue;
        const folderPath = `${folderSettings.path}/${folder}`;
        const existingFolder = this.app.vault.getAbstractFileByPath(folderPath);
        if (!existingFolder) {
          await this.app.vault.createFolder(folderPath);
        }
        for (const filename of files) {
          const file = allFiles.find((f) => f.name === filename);
          if (file) {
            const newPath = `${folderPath}/${filename}`;
            try {
              await this.app.fileManager.renameFile(file, newPath);
              movedCount++;
            } catch (e) {
              console.error(`Failed to move ${filename}:`, e);
            }
          }
        }
      }
      folderSettings.notesSinceLastOrganize = 0;
      await this.saveSettings();
      if (notice)
        notice.hide();
      if (!silent)
        new import_obsidian3.Notice(`Organized ${movedCount} notes into subfolders`);
    } catch (error) {
      if (notice)
        notice.hide();
      console.error("Error organizing Wonderland:", error);
      if (!silent)
        new import_obsidian3.Notice(`Error: ${AIService.getUserFriendlyError(error)}`);
    }
  }
  // Increment the note counter and trigger reorganization if threshold reached
  async incrementNoteCounterAndCheckReorganize(folderSettings) {
    if (!folderSettings.organizeOnNoteCount)
      return;
    folderSettings.notesSinceLastOrganize = (folderSettings.notesSinceLastOrganize || 0) + 1;
    await this.saveSettings();
    console.log(`Wonderland - Notes since last organize: ${folderSettings.notesSinceLastOrganize}/${folderSettings.organizeNoteCountThreshold}`);
    if (folderSettings.notesSinceLastOrganize >= folderSettings.organizeNoteCountThreshold) {
      console.log("Wonderland - Note count threshold reached, triggering reorganization");
      await this.organizeWonderlandFolder(folderSettings, true);
    }
  }
  // Generate or update the Rabbit Holes Index showing all unresolved links
  async generateRabbitHolesIndex(folderSettings, silent = false) {
    const notice = silent ? null : new import_obsidian3.Notice("Generating Rabbit Holes index...", 0);
    try {
      const unresolvedLinks = await this.getUnresolvedLinksInFolder(folderSettings.path);
      if (unresolvedLinks.length === 0) {
        if (notice)
          notice.hide();
        if (!silent)
          new import_obsidian3.Notice("No unresolved links found - all rabbit holes have been explored!");
        return;
      }
      const linksList = unresolvedLinks.map((link) => `- [[${link}]]`).join("\n");
      const prompt = RABBIT_HOLES_INDEX_PROMPT + linksList;
      const response = await this.aiService.generate(
        prompt,
        "You are organizing unexplored paths in a knowledge wonderland."
      );
      const indexName = this.getRabbitHolesIndexName(folderSettings.path);
      const indexPath = `${folderSettings.path}/${indexName}.md`;
      const content = `---
generated: ${(/* @__PURE__ */ new Date()).toISOString()}
type: rabbit-holes-index
wonderland: ${folderSettings.path}
---

# ${indexName}

> \u{1F430} These are the unexplored rabbit holes waiting to be discovered. Click any link to begin your journey down the hole!

${response.content}

---
*${unresolvedLinks.length} rabbit holes waiting to be explored*
`;
      const existingFile = this.app.vault.getAbstractFileByPath(indexPath);
      if (existingFile instanceof import_obsidian3.TFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(indexPath, content);
      }
      if (notice)
        notice.hide();
      if (!silent)
        new import_obsidian3.Notice(`Rabbit Holes index updated: ${unresolvedLinks.length} unexplored links`);
      if (!silent) {
        const file = this.app.vault.getAbstractFileByPath(indexPath);
        if (file instanceof import_obsidian3.TFile) {
          await this.app.workspace.getLeaf().openFile(file);
        }
      }
    } catch (error) {
      if (notice)
        notice.hide();
      console.error("Error generating tunnels document:", error);
      if (!silent)
        new import_obsidian3.Notice(`Error: ${AIService.getUserFriendlyError(error)}`);
    }
  }
  // Get all unresolved links within a Wonderland folder
  async getUnresolvedLinksInFolder(folderPath) {
    const unresolvedLinks = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(folderPath + "/"));
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const linkMatches = content.match(/\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/g);
      if (!linkMatches)
        continue;
      for (const match of linkMatches) {
        const linkText = match.slice(2, -2).split("|")[0];
        const linkedFile = this.app.metadataCache.getFirstLinkpathDest(linkText, file.path);
        if (!linkedFile) {
          unresolvedLinks.add(linkText);
        }
      }
    }
    const tunnelsDocName = this.getRabbitHolesIndexName(folderPath);
    unresolvedLinks.delete(tunnelsDocName);
    return Array.from(unresolvedLinks).sort();
  }
  async generateContentForNote(file, folderSettings) {
    if (!this.validateSettings())
      return;
    const title = file.basename;
    const notice = new import_obsidian3.Notice(`Going down the rabbit hole: ${title}...`, 0);
    try {
      const existingNotes = this.getExistingNoteTitles(folderSettings.path).filter((n) => n !== title);
      const userPrompt = PLACEHOLDER_NOTE_USER_PROMPT(
        title,
        "",
        "New note",
        existingNotes
      );
      let systemPrompt = PLACEHOLDER_NOTE_SYSTEM_PROMPT;
      if (folderSettings.folderGoal) {
        systemPrompt = FOLDER_GOAL_WRAPPER(
          folderSettings.folderGoal,
          folderSettings.customGoalDescription || "",
          systemPrompt
        );
      }
      if (folderSettings.customInstructions) {
        systemPrompt = CUSTOM_INSTRUCTIONS_WRAPPER(folderSettings.customInstructions, systemPrompt);
      }
      if (folderSettings.includeExternalLinks) {
        systemPrompt += EXTERNAL_LINKS_PROMPT(folderSettings.maxExternalLinks || 3);
      }
      const response = await this.aiService.generate(userPrompt, systemPrompt);
      const generatedContent = response.content;
      const formattedContent = await this.formatNote(generatedContent, folderSettings, void 0, title, true, file.path);
      await this.app.vault.modify(file, formattedContent);
      if (folderSettings.autoClassifyNewNotes) {
        const classifiedFolder = await this.classifyNoteIntoFolder(title, generatedContent, folderSettings);
        if (classifiedFolder && classifiedFolder !== "uncategorized") {
          const newFolderPath = `${folderSettings.path}/${classifiedFolder}`;
          await this.ensureFolderExists(newFolderPath);
          const newFilePath = `${newFolderPath}/${file.name}`;
          try {
            await this.app.fileManager.renameFile(file, newFilePath);
            console.log(`Wonderland - Moved note to: ${classifiedFolder}`);
          } catch (e) {
            console.error("Wonderland - Failed to move note:", e);
          }
        }
      }
      await this.incrementNoteCounterAndCheckReorganize(folderSettings);
      if (folderSettings.autoUpdateRabbitHolesIndex) {
        await this.generateRabbitHolesIndex(folderSettings, true);
      }
      notice.hide();
      new import_obsidian3.Notice(`Generated: ${title}`);
    } catch (error) {
      notice.hide();
      console.error("Error generating note content:", error);
      new import_obsidian3.Notice(`Error: ${AIService.getUserFriendlyError(error)}`);
    }
  }
  async handleFileOpen(file) {
    if (file.extension !== "md")
      return;
    if (this.isUntitledNote(file.basename)) {
      console.log("Wonderland - Untitled note detected, skipping auto-generation");
      this.pendingGenerations.delete(file.path);
      return;
    }
    const sourceWonderlandPath = this.pendingGenerations.get(file.path);
    if (!sourceWonderlandPath) {
      console.log("Wonderland - Note not from link click, skipping auto-generation");
      return;
    }
    const folderSettings = this.settings.wonderlandFolders.find((f) => f.path === sourceWonderlandPath);
    if (!folderSettings) {
      console.log("Wonderland - Source folder no longer configured, skipping");
      this.pendingGenerations.delete(file.path);
      return;
    }
    if (!folderSettings.autoGenerateEmptyNotes) {
      console.log("Wonderland - Auto-generation disabled for this folder");
      this.pendingGenerations.delete(file.path);
      return;
    }
    this.pendingGenerations.delete(file.path);
    if (!this.validateSettings())
      return;
    const content = await this.app.vault.read(file);
    const trimmedContent = content.trim();
    if (trimmedContent.length > 0) {
      console.log("Wonderland - Note has content, skipping auto-generation");
      return;
    }
    console.log("Wonderland - Empty note from link click detected:", file.basename);
    console.log("Wonderland - Will place in folder:", sourceWonderlandPath);
    const isInCorrectFolder = file.path.startsWith(sourceWonderlandPath + "/");
    if (!isInCorrectFolder) {
      await this.ensureFolderExists(sourceWonderlandPath);
      const newPath = `${sourceWonderlandPath}/${file.name}`;
      try {
        console.log("Wonderland - Moving file from", file.path, "to", newPath);
        await this.app.fileManager.renameFile(file, newPath);
        const movedFile = this.app.vault.getAbstractFileByPath(newPath);
        if (movedFile instanceof import_obsidian3.TFile) {
          await this.generateContentForNote(movedFile, folderSettings);
        }
      } catch (e) {
        console.error("Wonderland - Failed to move file:", e);
        await this.generateContentForNote(file, folderSettings);
      }
    } else {
      await this.generateContentForNote(file, folderSettings);
    }
  }
  async getSourceContext(linkText, sourceFile) {
    if (!sourceFile)
      return "";
    const content = await this.app.vault.read(sourceFile);
    const lines = content.split("\n");
    const linkPattern = new RegExp(`\\[\\[${this.escapeRegExp(linkText)}\\]\\]`, "i");
    const contextLines = [];
    for (let i = 0; i < lines.length; i++) {
      if (linkPattern.test(lines[i])) {
        const start = Math.max(0, i - 2);
        const end = Math.min(lines.length - 1, i + 2);
        contextLines.push(...lines.slice(start, end + 1));
      }
    }
    return contextLines.join("\n").substring(0, 500);
  }
  async generateTitle(content) {
    try {
      const response = await this.aiService.generate(
        TITLE_GENERATION_PROMPT + content.substring(0, 1e3),
        "You are a helpful assistant that generates concise titles."
      );
      return this.sanitizeFileName(response.content.trim());
    } catch (error) {
      console.error("Error generating title:", error);
      const firstLine = content.split("\n")[0].replace(/[#*_\[\]]/g, "").trim();
      return this.sanitizeFileName(firstLine.substring(0, 50) || `Note ${Date.now()}`);
    }
  }
  async formatNote(content, folderSettings, prompt, concept, includeQuestions = true, actualFilePath) {
    let formatted = "";
    const wonderlandPath = actualFilePath ? this.getWonderlandFolderFor(actualFilePath) || folderSettings.path : folderSettings.path;
    if (folderSettings.includeMetadata) {
      formatted += "---\n";
      formatted += `created: ${(/* @__PURE__ */ new Date()).toISOString()}
`;
      formatted += `source: ${prompt ? "prompt" : "placeholder"}
`;
      if (prompt) {
        formatted += `prompt: "${prompt.replace(/"/g, '\\"')}"
`;
      }
      if (concept) {
        formatted += `concept: "${concept.replace(/"/g, '\\"')}"
`;
      }
      formatted += `model: ${this.settings.model}
`;
      formatted += `wonderland: ${wonderlandPath}
`;
      if (folderSettings.folderGoal && folderSettings.folderGoal !== "learn") {
        formatted += `goal: ${folderSettings.folderGoal}
`;
      }
      formatted += "tags: [evergreen]\n";
      formatted += "---\n\n";
    }
    formatted += content;
    if (includeQuestions && folderSettings.includeFollowUpQuestions) {
      try {
        const questions = await this.generateRabbitHoleQuestions(content, folderSettings);
        if (questions) {
          formatted += "\n\n---\n\n## Down the rabbit hole\n\n";
          formatted += questions;
        }
      } catch (error) {
        console.error("Error generating rabbit hole questions:", error);
      }
    }
    return formatted;
  }
  async generateRabbitHoleQuestions(content, folderSettings) {
    let prompt = RABBIT_HOLE_QUESTIONS_PROMPT + content.substring(0, 1500);
    if ((folderSettings == null ? void 0 : folderSettings.customizeSuggestions) && (folderSettings == null ? void 0 : folderSettings.userInterests)) {
      prompt += PERSONALIZED_SUGGESTIONS_PROMPT(folderSettings.userInterests);
    }
    const response = await this.aiService.generate(
      prompt,
      "You are a curious guide to wonderland, creating doorways to deeper knowledge. Each question you ask becomes a portal to explore."
    );
    return response.content.trim();
  }
  async saveNote(title, content, folderSettings) {
    await this.ensureFolderExists(folderSettings.path);
    let targetFolder = folderSettings.path;
    if (folderSettings.autoClassifyNewNotes) {
      const classifiedFolder = await this.classifyNoteIntoFolder(title, content, folderSettings);
      if (classifiedFolder && classifiedFolder !== "uncategorized") {
        targetFolder = `${folderSettings.path}/${classifiedFolder}`;
        await this.ensureFolderExists(targetFolder);
        console.log(`Wonderland - Auto-classified note into: ${classifiedFolder}`);
      }
    }
    const filePath = await this.getAvailableFilePath(title, targetFolder);
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  async classifyNoteIntoFolder(title, content, folderSettings) {
    try {
      const subfolders = await this.getWonderlandSubfolders(folderSettings.path);
      if (subfolders.length === 0) {
        console.log("Wonderland - No subfolders exist yet, skipping classification");
        return null;
      }
      let folderContext = "";
      for (const subfolder of subfolders) {
        const folderPath = `${folderSettings.path}/${subfolder.name}`;
        const notesInFolder = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(folderPath + "/")).map((f) => f.basename).slice(0, 10);
        folderContext += `
${subfolder.name}/
`;
        folderContext += notesInFolder.map((n) => `  - ${n}`).join("\n");
      }
      const prompt = CLASSIFY_NOTE_PROMPT + folderContext + `

New note to classify:
Title: ${title}
Content preview: ${content.substring(0, 500)}...

Which folder should this note go in? Respond with ONLY the folder name.`;
      const response = await this.aiService.generate(
        prompt,
        "You are a librarian classifying a new book into the appropriate section."
      );
      const suggestedFolder = response.content.trim().toLowerCase().replace(/[^a-z0-9-_]/g, "");
      const validFolders = subfolders.map((f) => f.name.toLowerCase());
      if (validFolders.includes(suggestedFolder)) {
        const originalFolder = subfolders.find((f) => f.name.toLowerCase() === suggestedFolder);
        return (originalFolder == null ? void 0 : originalFolder.name) || null;
      }
      return null;
    } catch (error) {
      console.error("Wonderland - Error classifying note:", error);
      return null;
    }
  }
  async getWonderlandSubfolders(basePath) {
    const baseFolderAbstract = this.app.vault.getAbstractFileByPath(basePath);
    if (!baseFolderAbstract)
      return [];
    const subfolders = [];
    const allFiles = this.app.vault.getAllLoadedFiles();
    for (const file of allFiles) {
      if (file.path.startsWith(basePath + "/") && "children" in file) {
        const relativePath = file.path.replace(basePath + "/", "");
        if (!relativePath.includes("/")) {
          subfolders.push({ name: file.name, path: file.path });
        }
      }
    }
    return subfolders;
  }
  async getAvailableFilePath(baseName, folder) {
    const sanitized = this.sanitizeFileName(baseName);
    let filePath = `${folder}/${sanitized}.md`;
    let counter = 1;
    while (this.app.vault.getAbstractFileByPath(filePath)) {
      filePath = `${folder}/${sanitized} ${counter}.md`;
      counter++;
    }
    return filePath;
  }
  async ensureFolderExists(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  getExistingNoteTitles(folderPath) {
    let files = this.app.vault.getMarkdownFiles();
    if (folderPath) {
      files = files.filter((f) => f.path.startsWith(folderPath + "/") || f.path === folderPath);
    }
    return files.map((f) => f.basename).slice(0, 50);
  }
  // Get all folders in the vault (for folder picker)
  getAllVaultFolders() {
    const folders = [];
    const allFiles = this.app.vault.getAllLoadedFiles();
    for (const file of allFiles) {
      if (file instanceof import_obsidian3.TFolder && file.path !== "/") {
        folders.push(file.path);
      }
    }
    folders.sort();
    return folders;
  }
  validateSettings() {
    if (this.settings.aiProvider !== "ollama" && !this.settings.apiKey) {
      new import_obsidian3.Notice("Please configure your API key in settings");
      return false;
    }
    if (!this.settings.model) {
      new import_obsidian3.Notice("Please select a model in settings");
      return false;
    }
    return true;
  }
  sanitizeFileName(name) {
    return name.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim().substring(0, 100);
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
var PromptModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, onSubmit) {
    super(app);
    this.isCreatingNewFolder = false;
    this.plugin = plugin;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Enter Wonderland" });
    contentEl.createEl("p", {
      text: "What rabbit hole would you like to explore?",
      cls: "wonderland-prompt-description"
    });
    const folderContainer = contentEl.createDiv({ cls: "wonderland-folder-select" });
    folderContainer.style.marginBottom = "1em";
    folderContainer.createEl("label", { text: "Create in: " });
    this.folderSelect = folderContainer.createEl("select");
    this.folderSelect.style.marginRight = "0.5em";
    const currentFolderPath = this.plugin.getCurrentFolderPath();
    let defaultFolderPath = null;
    if (currentFolderPath) {
      const currentWonderland = this.plugin.getWonderlandSettingsFor(currentFolderPath);
      if (currentWonderland) {
        defaultFolderPath = currentWonderland.path;
      }
    }
    for (const folder of this.plugin.settings.wonderlandFolders) {
      const option = this.folderSelect.createEl("option", {
        text: folder.path,
        value: folder.path
      });
      if (folder.path === defaultFolderPath) {
        option.selected = true;
      }
    }
    if (currentFolderPath && !this.plugin.isInWonderland(currentFolderPath)) {
      const option = this.folderSelect.createEl("option", {
        text: `\u{1F4C1} ${currentFolderPath} (make Wonderland)`,
        value: `__current__:${currentFolderPath}`
      });
    }
    const newFolderOption = this.folderSelect.createEl("option", {
      text: "\u2795 Create new Wonderland folder...",
      value: "__new__"
    });
    this.newFolderContainer = folderContainer.createDiv({ cls: "wonderland-new-folder-input" });
    this.newFolderContainer.style.display = "none";
    this.newFolderContainer.style.marginTop = "0.5em";
    this.newFolderInput = this.newFolderContainer.createEl("input", {
      type: "text",
      placeholder: "Enter new folder name..."
    });
    this.newFolderInput.style.width = "100%";
    this.folderSelect.addEventListener("change", () => {
      const value = this.folderSelect.value;
      if (value === "__new__") {
        this.newFolderContainer.style.display = "block";
        this.isCreatingNewFolder = true;
        this.newFolderInput.focus();
      } else {
        this.newFolderContainer.style.display = "none";
        this.isCreatingNewFolder = false;
      }
    });
    this.textArea = contentEl.createEl("textarea", {
      cls: "wonderland-prompt-input",
      attr: {
        placeholder: 'e.g., "Why do we dream?" or "The science of curiosity"',
        rows: "4"
      }
    });
    this.textArea.style.width = "100%";
    this.textArea.style.marginBottom = "1em";
    this.textArea.style.padding = "0.5em";
    this.textArea.style.resize = "vertical";
    setTimeout(() => this.textArea.focus(), 10);
    const buttonContainer = contentEl.createDiv({ cls: "wonderland-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "0.5em";
    const cancelBtn = buttonContainer.createEl("button", { text: "Stay here" });
    cancelBtn.addEventListener("click", () => this.close());
    const exploreBtn = buttonContainer.createEl("button", {
      text: "Down the rabbit hole",
      cls: "mod-cta"
    });
    exploreBtn.addEventListener("click", () => this.submit());
    this.textArea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        this.submit();
      }
    });
  }
  async submit() {
    var _a, _b;
    const prompt = this.textArea.value.trim();
    if (!prompt) {
      new import_obsidian3.Notice("Please enter something to explore");
      return;
    }
    let folderPath;
    const selectedValue = ((_a = this.folderSelect) == null ? void 0 : _a.value) || "";
    if (selectedValue === "__new__") {
      const newFolderName = this.newFolderInput.value.trim();
      if (!newFolderName) {
        new import_obsidian3.Notice("Please enter a folder name");
        return;
      }
      folderPath = newFolderName;
      try {
        await this.plugin.ensureFolderExists(folderPath);
        const newSettings = createFolderSettings(folderPath);
        this.plugin.settings.wonderlandFolders.push(newSettings);
        await this.plugin.saveSettings();
        new import_obsidian3.Notice(`Created new Wonderland: ${folderPath}`);
      } catch (e) {
        new import_obsidian3.Notice(`Failed to create folder: ${e}`);
        return;
      }
    } else if (selectedValue.startsWith("__current__:")) {
      folderPath = selectedValue.replace("__current__:", "");
      this.close();
      new NewWonderlandSetupModal(this.app, this.plugin, folderPath, async (settings) => {
        this.plugin.settings.wonderlandFolders.push(settings);
        await this.plugin.saveSettings();
        new import_obsidian3.Notice(`${folderPath} is now a Wonderland!`);
        await this.plugin.generateNoteFromPrompt(prompt, folderPath);
      }).open();
      return;
    } else if (selectedValue) {
      folderPath = selectedValue;
    } else {
      folderPath = (_b = this.plugin.settings.wonderlandFolders[0]) == null ? void 0 : _b.path;
    }
    if (!folderPath) {
      new import_obsidian3.Notice("Please select or create a Wonderland folder");
      return;
    }
    this.close();
    this.onSubmit(prompt, folderPath);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var NewWonderlandSetupModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, folderPath, onComplete) {
    super(app);
    this.plugin = plugin;
    this.folderPath = folderPath;
    this.onComplete = onComplete;
    this.settings = createFolderSettings(folderPath);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: `Setup: ${this.folderPath}` });
    contentEl.createEl("p", {
      text: "Customize this Wonderland before creating your first note:",
      cls: "wonderland-setup-description"
    }).style.color = "var(--text-muted)";
    const goalContainer = contentEl.createDiv({ cls: "wonderland-setup-goal" });
    goalContainer.style.marginBottom = "1em";
    goalContainer.createEl("label", { text: "Folder Goal:" }).style.display = "block";
    goalContainer.createEl("small", {
      text: "This affects how AI generates content for this Wonderland"
    }).style.cssText = "display: block; color: var(--text-muted); margin-bottom: 0.5em;";
    const goalSelect = goalContainer.createEl("select");
    goalSelect.style.width = "100%";
    const goals = [
      { value: "learn", label: "\u{1F4DA} Learning", desc: "Optimized for understanding and retention" },
      { value: "action", label: "\u2705 Action-Oriented", desc: "Practical steps and how-to guides" },
      { value: "reflect", label: "\u{1F914} Critical Reflection", desc: "Deep thinking and multiple perspectives" },
      { value: "research", label: "\u{1F52C} Research", desc: "Evidence-based with citations" },
      { value: "creative", label: "\u{1F3A8} Creative", desc: "Imaginative and unconventional connections" },
      { value: "custom", label: "\u2699\uFE0F Custom", desc: "Define your own focus" }
    ];
    for (const goal of goals) {
      goalSelect.createEl("option", {
        text: `${goal.label} - ${goal.desc}`,
        value: goal.value
      });
    }
    const customGoalContainer = goalContainer.createDiv();
    customGoalContainer.style.display = "none";
    customGoalContainer.style.marginTop = "0.5em";
    const customGoalInput = customGoalContainer.createEl("textarea", {
      placeholder: "Describe the focus for this Wonderland..."
    });
    customGoalInput.style.cssText = "width: 100%; height: 60px;";
    goalSelect.addEventListener("change", () => {
      this.settings.folderGoal = goalSelect.value;
      customGoalContainer.style.display = goalSelect.value === "custom" ? "block" : "none";
    });
    customGoalInput.addEventListener("input", () => {
      this.settings.customGoalDescription = customGoalInput.value;
    });
    const instructionsContainer = contentEl.createDiv({ cls: "wonderland-setup-instructions" });
    instructionsContainer.style.marginBottom = "1em";
    instructionsContainer.createEl("label", { text: "Custom Instructions (optional):" }).style.display = "block";
    instructionsContainer.createEl("small", {
      text: 'E.g., "Generate notes as step-by-step cooking guides"'
    }).style.cssText = "display: block; color: var(--text-muted); margin-bottom: 0.5em;";
    const instructionsInput = instructionsContainer.createEl("textarea", {
      placeholder: "Special instructions for AI generation..."
    });
    instructionsInput.style.cssText = "width: 100%; height: 60px;";
    instructionsInput.addEventListener("input", () => {
      this.settings.customInstructions = instructionsInput.value;
    });
    const togglesContainer = contentEl.createDiv({ cls: "wonderland-setup-toggles" });
    togglesContainer.style.marginBottom = "1.5em";
    const toggles = [
      { key: "includeExternalLinks", label: "\u{1F517} Include external reference links", default: false },
      { key: "customizeSuggestions", label: '\u{1F3AF} Personalize "rabbit hole" suggestions', default: false }
    ];
    for (const toggle of toggles) {
      const toggleDiv = togglesContainer.createDiv();
      toggleDiv.style.cssText = "display: flex; align-items: center; margin-bottom: 0.5em;";
      const checkbox = toggleDiv.createEl("input", { type: "checkbox" });
      checkbox.checked = toggle.default;
      checkbox.style.marginRight = "0.5em";
      toggleDiv.createEl("label", { text: toggle.label });
      checkbox.addEventListener("change", () => {
        this.settings[toggle.key] = checkbox.checked;
      });
    }
    const interestsContainer = contentEl.createDiv({ cls: "wonderland-setup-interests" });
    interestsContainer.style.marginBottom = "1em";
    interestsContainer.createEl("label", { text: "Your Interests (optional):" }).style.display = "block";
    interestsContainer.createEl("small", {
      text: "Comma-separated list to personalize suggestions"
    }).style.cssText = "display: block; color: var(--text-muted); margin-bottom: 0.5em;";
    const interestsInput = interestsContainer.createEl("input", {
      type: "text",
      placeholder: "e.g., philosophy, AI, cooking, music"
    });
    interestsInput.style.width = "100%";
    interestsInput.addEventListener("input", () => {
      this.settings.userInterests = interestsInput.value;
    });
    const buttonContainer = contentEl.createDiv({ cls: "wonderland-setup-buttons" });
    buttonContainer.style.cssText = "display: flex; justify-content: flex-end; gap: 0.5em;";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
    const createBtn = buttonContainer.createEl("button", {
      text: "Create Wonderland",
      cls: "mod-cta"
    });
    createBtn.addEventListener("click", () => {
      this.close();
      this.onComplete(this.settings);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var WelcomeModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, onComplete) {
    super(app);
    this.plugin = plugin;
    this.onComplete = onComplete;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("wonderland-welcome-modal");
    contentEl.createEl("div", {
      text: "\u{1F430}",
      cls: "wonderland-welcome-emoji"
    }).style.cssText = "font-size: 4em; text-align: center; margin-bottom: 0.5em;";
    contentEl.createEl("h1", {
      text: "Welcome to Wonderland",
      cls: "wonderland-welcome-title"
    }).style.cssText = "text-align: center; margin-bottom: 0.5em;";
    contentEl.createEl("p", {
      text: "Go down the rabbit hole of knowledge",
      cls: "wonderland-welcome-subtitle"
    }).style.cssText = "text-align: center; color: var(--text-muted); margin-bottom: 1.5em; font-style: italic;";
    const featuresContainer = contentEl.createDiv({ cls: "wonderland-features" });
    featuresContainer.style.cssText = "margin-bottom: 1.5em;";
    const features = [
      {
        emoji: "\u2728",
        title: "AI-Powered Exploration",
        desc: "Ask a question and watch knowledge unfold with linked notes"
      },
      {
        emoji: "\u{1F517}",
        title: "Linked Doorways",
        desc: "Click any [[link]] to auto-generate connected concepts"
      },
      {
        emoji: "\u{1F5C2}\uFE0F",
        title: "Smart Organization",
        desc: "Let AI organize your notes into thematic folders"
      },
      {
        emoji: "\u{1F4DA}",
        title: "Multiple Wonderlands",
        desc: "Create separate knowledge gardens for different domains"
      }
    ];
    for (const feature of features) {
      const featureEl = featuresContainer.createDiv({ cls: "wonderland-feature" });
      featureEl.style.cssText = "display: flex; align-items: flex-start; margin-bottom: 1em;";
      const emojiEl = featureEl.createSpan({ text: feature.emoji });
      emojiEl.style.cssText = "font-size: 1.5em; margin-right: 0.75em;";
      const textEl = featureEl.createDiv();
      textEl.createEl("strong", { text: feature.title });
      textEl.createEl("p", { text: feature.desc }).style.cssText = "margin: 0.25em 0 0 0; color: var(--text-muted); font-size: 0.9em;";
    }
    const gettingStarted = contentEl.createDiv({ cls: "wonderland-getting-started" });
    gettingStarted.style.cssText = "background: var(--background-secondary); padding: 1em; border-radius: 8px; margin-bottom: 1.5em;";
    gettingStarted.createEl("h3", { text: "\u{1F680} Quick Start" }).style.marginTop = "0";
    const steps = gettingStarted.createEl("ol");
    steps.style.cssText = "margin: 0.5em 0; padding-left: 1.5em;";
    const stepItems = [
      "Configure your AI provider in Settings \u2192 Wonderland",
      "Add a Wonderland folder (where your notes will live)",
      "Click the \u{1F430} rabbit icon or use the command palette",
      "Enter a question and start exploring!"
    ];
    for (const step of stepItems) {
      steps.createEl("li", { text: step }).style.marginBottom = "0.5em";
    }
    const buttonContainer = contentEl.createDiv({ cls: "wonderland-welcome-buttons" });
    buttonContainer.style.cssText = "display: flex; justify-content: center; gap: 1em;";
    const settingsBtn = buttonContainer.createEl("button", { text: "Open Settings" });
    settingsBtn.addEventListener("click", () => {
      this.close();
      this.app.setting.open();
      this.app.setting.openTabById("wonderland");
    });
    const exploreBtn = buttonContainer.createEl("button", {
      text: "Start Exploring",
      cls: "mod-cta"
    });
    exploreBtn.addEventListener("click", () => {
      this.close();
      if (this.plugin.settings.wonderlandFolders.length === 0) {
        new import_obsidian3.Notice("Add a Wonderland folder in settings first");
        this.app.setting.open();
        this.app.setting.openTabById("wonderland");
      } else if (!this.plugin.settings.apiKey && this.plugin.settings.aiProvider !== "ollama") {
        new import_obsidian3.Notice("Configure your API key in settings first");
        this.app.setting.open();
        this.app.setting.openTabById("wonderland");
      } else {
        this.plugin.openPromptModal();
      }
    });
    const footer = contentEl.createDiv({ cls: "wonderland-welcome-footer" });
    footer.style.cssText = "text-align: center; margin-top: 1em; color: var(--text-muted); font-size: 0.85em;";
    footer.createEl("p", { text: '"Curiouser and curiouser!" - Alice' }).style.fontStyle = "italic";
    const supportLink = footer.createEl("p");
    supportLink.innerHTML = 'Enjoying Wonderland? <a href="https://ko-fi.com/donjguido" target="_blank">Support development</a>';
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.onComplete();
  }
};
