/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EvergreenAIPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  aiProvider: "openai",
  apiKey: "",
  apiEndpoint: "",
  model: "gpt-4-turbo-preview",
  maxTokens: 2e3,
  temperature: 0.7,
  noteFolder: "Evergreen",
  titleStyle: "concept",
  includeMetadata: true,
  autoBacklinks: true,
  maxPlaceholderLinks: 7,
  placeholderIndicator: "\u2728",
  enableSuggestions: true,
  suggestionFrequency: "daily"
};
var PROVIDER_DEFAULTS = {
  openai: {
    endpoint: "https://api.openai.com/v1/chat/completions",
    models: ["gpt-4-turbo-preview", "gpt-4", "gpt-3.5-turbo"]
  },
  anthropic: {
    endpoint: "https://api.anthropic.com/v1/messages",
    models: ["claude-3-opus-20240229", "claude-3-sonnet-20240229", "claude-3-haiku-20240307"]
  },
  ollama: {
    endpoint: "http://localhost:11434/api/chat",
    models: ["llama2", "mistral", "mixtral", "codellama"]
  },
  custom: {
    endpoint: "",
    models: []
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var EvergreenAISettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Evergreen AI Settings" });
    containerEl.createEl("h2", { text: "AI Configuration" });
    new import_obsidian.Setting(containerEl).setName("AI Provider").setDesc("Select your AI provider").addDropdown(
      (dropdown) => dropdown.addOptions({
        openai: "OpenAI",
        anthropic: "Anthropic (Claude)",
        ollama: "Ollama (Local)",
        custom: "Custom Endpoint"
      }).setValue(this.plugin.settings.aiProvider).onChange(async (value) => {
        this.plugin.settings.aiProvider = value;
        const defaults = PROVIDER_DEFAULTS[value];
        if (defaults.models.length > 0) {
          this.plugin.settings.model = defaults.models[0];
        }
        if (defaults.endpoint) {
          this.plugin.settings.apiEndpoint = defaults.endpoint;
        }
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.aiProvider !== "ollama") {
      new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Your API key (stored locally, never sent anywhere except the AI provider)").addText(
        (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
          this.plugin.settings.apiKey = value;
          await this.plugin.saveSettings();
        })
      ).then((setting) => {
        const inputEl = setting.controlEl.querySelector("input");
        if (inputEl) {
          inputEl.type = "password";
        }
      });
    }
    if (this.plugin.settings.aiProvider === "custom" || this.plugin.settings.aiProvider === "ollama") {
      new import_obsidian.Setting(containerEl).setName("API Endpoint").setDesc("The API endpoint URL").addText(
        (text) => text.setPlaceholder("https://api.example.com/v1/chat/completions").setValue(this.plugin.settings.apiEndpoint).onChange(async (value) => {
          this.plugin.settings.apiEndpoint = value;
          await this.plugin.saveSettings();
        })
      );
    }
    const providerModels = PROVIDER_DEFAULTS[this.plugin.settings.aiProvider].models;
    if (providerModels.length > 0) {
      new import_obsidian.Setting(containerEl).setName("Model").setDesc("Select the AI model to use").addDropdown((dropdown) => {
        const options = {};
        providerModels.forEach((model) => {
          options[model] = model;
        });
        return dropdown.addOptions(options).setValue(this.plugin.settings.model).onChange(async (value) => {
          this.plugin.settings.model = value;
          await this.plugin.saveSettings();
        });
      });
    } else {
      new import_obsidian.Setting(containerEl).setName("Model").setDesc("Enter the model name").addText(
        (text) => text.setPlaceholder("gpt-4").setValue(this.plugin.settings.model).onChange(async (value) => {
          this.plugin.settings.model = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian.Setting(containerEl).setName("Max Tokens").setDesc("Maximum tokens in AI response (affects note length)").addSlider(
      (slider) => slider.setLimits(500, 4e3, 100).setValue(this.plugin.settings.maxTokens).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxTokens = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Temperature").setDesc("Controls randomness (0 = focused, 1 = creative)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Note Generation" });
    new import_obsidian.Setting(containerEl).setName("Notes Folder").setDesc("Where to save generated evergreen notes").addText(
      (text) => text.setPlaceholder("Evergreen").setValue(this.plugin.settings.noteFolder).onChange(async (value) => {
        this.plugin.settings.noteFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Title Style").setDesc("How to format note titles").addDropdown(
      (dropdown) => dropdown.addOptions({
        concept: "Concept (statement form)",
        question: "Question (interrogative)",
        statement: "Statement (declarative)"
      }).setValue(this.plugin.settings.titleStyle).onChange(async (value) => {
        this.plugin.settings.titleStyle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Include Metadata").setDesc("Add YAML frontmatter with generation info").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.includeMetadata).onChange(async (value) => {
        this.plugin.settings.includeMetadata = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto Backlinks").setDesc("Automatically maintain a backlinks section in notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoBacklinks).onChange(async (value) => {
        this.plugin.settings.autoBacklinks = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Placeholder Links" });
    new import_obsidian.Setting(containerEl).setName("Max Placeholder Links").setDesc("Maximum concept links to generate per note").addSlider(
      (slider) => slider.setLimits(1, 15, 1).setValue(this.plugin.settings.maxPlaceholderLinks).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxPlaceholderLinks = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Organization Suggestions" });
    new import_obsidian.Setting(containerEl).setName("Enable Suggestions").setDesc("Show AI-powered suggestions for organizing your notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableSuggestions).onChange(async (value) => {
        this.plugin.settings.enableSuggestions = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Suggestion Frequency").setDesc("How often to analyze and suggest organization improvements").addDropdown(
      (dropdown) => dropdown.addOptions({
        always: "On every note change",
        daily: "Once per day",
        weekly: "Once per week",
        manual: "Manual only"
      }).setValue(this.plugin.settings.suggestionFrequency).onChange(async (value) => {
        this.plugin.settings.suggestionFrequency = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Connection Test" });
    new import_obsidian.Setting(containerEl).setName("Test AI Connection").setDesc("Verify your API configuration is working").addButton(
      (button) => button.setButtonText("Test Connection").setCta().onClick(async () => {
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          await this.plugin.aiService.testConnection();
          button.setButtonText("Connected!");
          setTimeout(() => {
            button.setButtonText("Test Connection");
            button.setDisabled(false);
          }, 2e3);
        } catch (error) {
          button.setButtonText("Failed - Check Settings");
          setTimeout(() => {
            button.setButtonText("Test Connection");
            button.setDisabled(false);
          }, 3e3);
        }
      })
    );
  }
};

// src/services/AIService.ts
var import_obsidian2 = require("obsidian");
var AIService = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async testConnection() {
    try {
      const response = await this.generate('Say "connected" and nothing else.', "You are a helpful assistant.");
      return response.content.toLowerCase().includes("connected");
    } catch (error) {
      console.error("Connection test failed:", error);
      throw error;
    }
  }
  async generate(prompt, systemPrompt) {
    const { endpoint, headers, body } = this.buildRequest(prompt, systemPrompt, false);
    const response = await (0, import_obsidian2.requestUrl)({
      url: endpoint,
      method: "POST",
      headers,
      body: JSON.stringify(body)
    });
    return this.parseResponse(response.json);
  }
  async generateStream(prompt, systemPrompt, onChunk, onComplete) {
    var _a;
    const { endpoint, headers, body } = this.buildRequest(prompt, systemPrompt, true);
    const response = await fetch(endpoint, {
      method: "POST",
      headers,
      body: JSON.stringify(body)
    });
    if (!response.ok) {
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }
    const reader = (_a = response.body) == null ? void 0 : _a.getReader();
    if (!reader) {
      throw new Error("No response body");
    }
    const decoder = new TextDecoder();
    let buffer = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          const chunk = this.parseStreamChunk(line);
          if (chunk) {
            if (chunk.done) {
              onComplete();
              return;
            }
            if (chunk.content) {
              onChunk(chunk.content);
            }
          }
        }
      }
      if (buffer) {
        const chunk = this.parseStreamChunk(buffer);
        if (chunk == null ? void 0 : chunk.content) {
          onChunk(chunk.content);
        }
      }
      onComplete();
    } finally {
      reader.releaseLock();
    }
  }
  buildRequest(prompt, systemPrompt, stream) {
    const provider = this.settings.aiProvider;
    switch (provider) {
      case "openai":
        return this.buildOpenAIRequest(prompt, systemPrompt, stream);
      case "anthropic":
        return this.buildAnthropicRequest(prompt, systemPrompt, stream);
      case "ollama":
        return this.buildOllamaRequest(prompt, systemPrompt, stream);
      case "custom":
        return this.buildCustomRequest(prompt, systemPrompt, stream);
      default:
        throw new Error(`Unknown provider: ${provider}`);
    }
  }
  buildOpenAIRequest(prompt, systemPrompt, stream) {
    return {
      endpoint: this.settings.apiEndpoint || PROVIDER_DEFAULTS.openai.endpoint,
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.apiKey}`
      },
      body: {
        model: this.settings.model,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: prompt }
        ],
        max_tokens: this.settings.maxTokens,
        temperature: this.settings.temperature,
        stream
      }
    };
  }
  buildAnthropicRequest(prompt, systemPrompt, stream) {
    return {
      endpoint: this.settings.apiEndpoint || PROVIDER_DEFAULTS.anthropic.endpoint,
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.settings.apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: {
        model: this.settings.model,
        system: systemPrompt,
        messages: [
          { role: "user", content: prompt }
        ],
        max_tokens: this.settings.maxTokens,
        temperature: this.settings.temperature,
        stream
      }
    };
  }
  buildOllamaRequest(prompt, systemPrompt, stream) {
    return {
      endpoint: this.settings.apiEndpoint || PROVIDER_DEFAULTS.ollama.endpoint,
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        model: this.settings.model,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: prompt }
        ],
        stream,
        options: {
          temperature: this.settings.temperature,
          num_predict: this.settings.maxTokens
        }
      }
    };
  }
  buildCustomRequest(prompt, systemPrompt, stream) {
    return {
      endpoint: this.settings.apiEndpoint,
      headers: {
        "Content-Type": "application/json",
        ...this.settings.apiKey ? { "Authorization": `Bearer ${this.settings.apiKey}` } : {}
      },
      body: {
        model: this.settings.model,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: prompt }
        ],
        max_tokens: this.settings.maxTokens,
        temperature: this.settings.temperature,
        stream
      }
    };
  }
  parseResponse(json) {
    var _a, _b, _c;
    const provider = this.settings.aiProvider;
    switch (provider) {
      case "anthropic": {
        const content = json.content;
        return {
          content: ((_a = content == null ? void 0 : content[0]) == null ? void 0 : _a.text) || "",
          model: json.model,
          usage: json.usage ? {
            promptTokens: json.usage.input_tokens,
            completionTokens: json.usage.output_tokens
          } : void 0
        };
      }
      case "ollama": {
        const message = json.message;
        return {
          content: (message == null ? void 0 : message.content) || "",
          model: json.model
        };
      }
      case "openai":
      case "custom":
      default: {
        const choices = json.choices;
        return {
          content: ((_c = (_b = choices == null ? void 0 : choices[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || "",
          model: json.model,
          usage: json.usage ? {
            promptTokens: json.usage.prompt_tokens,
            completionTokens: json.usage.completion_tokens
          } : void 0
        };
      }
    }
  }
  parseStreamChunk(line) {
    var _a;
    const trimmed = line.trim();
    if (!trimmed || trimmed === "data: [DONE]") {
      return trimmed === "data: [DONE]" ? { content: "", done: true } : null;
    }
    const provider = this.settings.aiProvider;
    try {
      let data;
      if (trimmed.startsWith("data: ")) {
        data = JSON.parse(trimmed.slice(6));
      } else if (trimmed.startsWith("{")) {
        data = JSON.parse(trimmed);
      } else {
        return null;
      }
      switch (provider) {
        case "anthropic": {
          if (data.type === "content_block_delta") {
            const delta = data.delta;
            return { content: (delta == null ? void 0 : delta.text) || "", done: false };
          }
          if (data.type === "message_stop") {
            return { content: "", done: true };
          }
          return null;
        }
        case "ollama": {
          const message = data.message;
          const done = data.done;
          return {
            content: (message == null ? void 0 : message.content) || "",
            done: done || false
          };
        }
        case "openai":
        case "custom":
        default: {
          const choices = data.choices;
          if (!choices || choices.length === 0)
            return null;
          const choice = choices[0];
          if (choice.finish_reason === "stop") {
            return { content: "", done: true };
          }
          return {
            content: ((_a = choice.delta) == null ? void 0 : _a.content) || "",
            done: false
          };
        }
      }
    } catch (e) {
      return null;
    }
  }
};

// src/prompts/evergreenNote.ts
var EVERGREEN_NOTE_SYSTEM_PROMPT = `You are an expert at creating Evergreen Notes following Andy Matuschak's methodology.

PRINCIPLES:
1. ATOMIC: Each note addresses ONE concept fully
2. CONCEPT-ORIENTED: Title should be a clear concept statement, not a question
3. DENSELY LINKED: Include [[wikilinks]] to related concepts that deserve their own notes
4. PERSONAL VOICE: Write as if explaining to yourself, but publishable

FORMATTING:
- Start with a clear, direct statement of the concept
- Use short paragraphs (2-4 sentences each)
- Include [[placeholder links]] for concepts that deserve separate notes
- These linked concepts should be ATOMIC ideas, not just keywords
- End with connections to broader themes if relevant

PLACEHOLDER LINKS:
- Create [[links]] to concepts that are substantial enough for their own note
- Choose concept-oriented names (e.g., [[Spaced repetition enhances long-term memory]] not [[spaced repetition]])
- Aim for 3-7 meaningful links per note
- Only link concepts that would genuinely benefit from deeper exploration
- IMPORTANT: Link text should be a complete concept statement

OUTPUT FORMAT:
Return ONLY the note content in Markdown. No meta-commentary, no titles (title will be added separately).`;
var EVERGREEN_NOTE_USER_PROMPT = (prompt, context, existingNotes) => {
  let userPrompt = `Create an evergreen note answering this prompt:

"${prompt}"`;
  if (context) {
    userPrompt += `

Relevant context from existing notes:
${context}`;
  }
  if (existingNotes.length > 0) {
    userPrompt += `

These notes already exist in the knowledge base (you can link to them with [[Note Title]]):
${existingNotes.map((n) => `- ${n}`).join("\n")}`;
  }
  userPrompt += `

Remember: Include [[placeholder links]] for concepts that deserve their own atomic notes. Make link text concept-oriented statements.`;
  return userPrompt;
};
var TITLE_GENERATION_PROMPT = `Based on the following note content, generate a concise, concept-oriented title.

RULES:
- Title should be a statement or concept, not a question
- Keep it under 60 characters
- Make it specific and descriptive
- It should work as a "API" for the concept - others should understand what the note is about from the title alone

Return ONLY the title, nothing else.

Content:
`;

// src/prompts/placeholderNote.ts
var PLACEHOLDER_NOTE_SYSTEM_PROMPT = `You are creating an Evergreen Note for a concept that was linked from another note.

CONTEXT:
- This concept was mentioned in another note as worthy of deeper exploration
- You'll receive the concept name and the context where it was mentioned
- Create a complete, atomic note that fully explores this single concept

PRINCIPLES:
1. ATOMIC: Focus entirely on this one concept
2. COMPLETE: Provide a thorough exploration, not just a definition
3. LINKED: Include [[placeholder links]] to related concepts
4. STANDALONE: The note should make sense on its own

GUIDELINES:
- Start with a clear explanation of the concept
- Include examples, implications, or applications where relevant
- Add connections to related ideas via [[links]]
- Don't repeat information from the source note verbatim
- Add new insights, perspectives, or nuances

OUTPUT: Return ONLY the Markdown note content. No title, no meta-commentary.`;
var PLACEHOLDER_NOTE_USER_PROMPT = (concept, sourceContext, sourceNoteName, relatedNotes) => {
  let prompt = `Create an evergreen note for the concept: "${concept}"

This concept was mentioned in "${sourceNoteName}" in the following context:
"${sourceContext}"`;
  if (relatedNotes.length > 0) {
    prompt += `

Related notes in the knowledge base you can link to:
${relatedNotes.map((n) => `- ${n}`).join("\n")}`;
  }
  prompt += `

Create a complete, atomic note exploring this concept. Include appropriate [[placeholder links]] to other concepts that deserve their own notes.`;
  return prompt;
};

// src/main.ts
var EvergreenAIPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.aiService = new AIService(this.settings);
    this.addRibbonIcon("leaf", "Generate Evergreen Note", () => {
      this.openPromptModal();
    });
    this.addCommand({
      id: "generate-evergreen-note",
      name: "Generate evergreen note from prompt",
      callback: () => {
        this.openPromptModal();
      }
    });
    this.addCommand({
      id: "generate-from-selection",
      name: "Generate evergreen note from selection",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          this.generateNoteFromPrompt(selection);
        } else {
          new import_obsidian3.Notice("Please select some text first");
        }
      }
    });
    this.registerDomEvent(document, "click", async (evt) => {
      await this.handleLinkClick(evt);
    }, { capture: true });
    this.addSettingTab(new EvergreenAISettingTab(this.app, this));
    console.log("Evergreen AI plugin loaded");
  }
  onunload() {
    console.log("Evergreen AI plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    var _a;
    await this.saveData(this.settings);
    (_a = this.aiService) == null ? void 0 : _a.updateSettings(this.settings);
  }
  openPromptModal() {
    new PromptModal(this.app, async (prompt) => {
      await this.generateNoteFromPrompt(prompt);
    }).open();
  }
  async generateNoteFromPrompt(prompt) {
    if (!this.validateSettings())
      return;
    const notice = new import_obsidian3.Notice("Generating evergreen note...", 0);
    try {
      const existingNotes = this.getExistingNoteTitles();
      const userPrompt = EVERGREEN_NOTE_USER_PROMPT(prompt, "", existingNotes);
      let content = "";
      await this.aiService.generateStream(
        userPrompt,
        EVERGREEN_NOTE_SYSTEM_PROMPT,
        (chunk) => {
          content += chunk;
        },
        () => {
        }
      );
      const title = await this.generateTitle(content);
      const formattedContent = this.formatNote(content, prompt);
      const filePath = await this.saveNote(title, formattedContent);
      notice.hide();
      new import_obsidian3.Notice(`Created: ${title}`);
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian3.TFile) {
        await this.app.workspace.getLeaf().openFile(file);
      }
    } catch (error) {
      notice.hide();
      console.error("Error generating note:", error);
      new import_obsidian3.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async handleLinkClick(evt) {
    const target = evt.target;
    if (!target.classList.contains("internal-link"))
      return;
    const linkText = target.getAttribute("data-href");
    if (!linkText)
      return;
    const linkedFile = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
    if (linkedFile)
      return;
    evt.preventDefault();
    evt.stopPropagation();
    if (!this.validateSettings())
      return;
    const notice = new import_obsidian3.Notice(`Generating: ${linkText}...`, 0);
    try {
      const activeFile = this.app.workspace.getActiveFile();
      const sourceContext = await this.getSourceContext(linkText, activeFile);
      const relatedNotes = this.getExistingNoteTitles();
      const userPrompt = PLACEHOLDER_NOTE_USER_PROMPT(
        linkText,
        sourceContext,
        (activeFile == null ? void 0 : activeFile.basename) || "Unknown",
        relatedNotes
      );
      let content = "";
      const filePath = await this.getAvailableFilePath(linkText);
      const folder = this.settings.noteFolder;
      await this.ensureFolderExists(folder);
      const initialContent = this.formatNote("*Drafting...*\n\n", void 0, linkText);
      await this.app.vault.create(filePath, initialContent);
      const newFile = this.app.vault.getAbstractFileByPath(filePath);
      if (newFile instanceof import_obsidian3.TFile) {
        const leaf = this.app.workspace.getLeaf();
        await leaf.openFile(newFile);
        await this.aiService.generateStream(
          userPrompt,
          PLACEHOLDER_NOTE_SYSTEM_PROMPT,
          async (chunk) => {
            content += chunk;
            const formattedContent = this.formatNote(content, void 0, linkText);
            await this.app.vault.modify(newFile, formattedContent);
          },
          async () => {
            const formattedContent = this.formatNote(content, void 0, linkText);
            await this.app.vault.modify(newFile, formattedContent);
          }
        );
      }
      notice.hide();
      new import_obsidian3.Notice(`Created: ${linkText}`);
    } catch (error) {
      notice.hide();
      console.error("Error generating placeholder note:", error);
      new import_obsidian3.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async getSourceContext(linkText, sourceFile) {
    if (!sourceFile)
      return "";
    const content = await this.app.vault.read(sourceFile);
    const lines = content.split("\n");
    const linkPattern = new RegExp(`\\[\\[${this.escapeRegExp(linkText)}\\]\\]`, "i");
    const contextLines = [];
    for (let i = 0; i < lines.length; i++) {
      if (linkPattern.test(lines[i])) {
        const start = Math.max(0, i - 2);
        const end = Math.min(lines.length - 1, i + 2);
        contextLines.push(...lines.slice(start, end + 1));
      }
    }
    return contextLines.join("\n").substring(0, 500);
  }
  async generateTitle(content) {
    try {
      const response = await this.aiService.generate(
        TITLE_GENERATION_PROMPT + content.substring(0, 1e3),
        "You are a helpful assistant that generates concise titles."
      );
      return this.sanitizeFileName(response.content.trim());
    } catch (error) {
      console.error("Error generating title:", error);
      const firstLine = content.split("\n")[0].replace(/[#*_\[\]]/g, "").trim();
      return this.sanitizeFileName(firstLine.substring(0, 50) || `Note ${Date.now()}`);
    }
  }
  formatNote(content, prompt, concept) {
    let formatted = "";
    if (this.settings.includeMetadata) {
      formatted += "---\n";
      formatted += `created: ${(/* @__PURE__ */ new Date()).toISOString()}
`;
      formatted += `source: ${prompt ? "prompt" : "placeholder"}
`;
      if (prompt) {
        formatted += `prompt: "${prompt.replace(/"/g, '\\"')}"
`;
      }
      if (concept) {
        formatted += `concept: "${concept.replace(/"/g, '\\"')}"
`;
      }
      formatted += `model: ${this.settings.model}
`;
      formatted += "tags: [evergreen]\n";
      formatted += "---\n\n";
    }
    formatted += content;
    if (this.settings.autoBacklinks) {
      formatted += "\n\n---\n\n## Backlinks\n\n";
      formatted += "*Links to this note will appear here*\n";
    }
    return formatted;
  }
  async saveNote(title, content) {
    const folder = this.settings.noteFolder;
    await this.ensureFolderExists(folder);
    const filePath = await this.getAvailableFilePath(title);
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  async getAvailableFilePath(baseName) {
    const folder = this.settings.noteFolder;
    const sanitized = this.sanitizeFileName(baseName);
    let filePath = `${folder}/${sanitized}.md`;
    let counter = 1;
    while (this.app.vault.getAbstractFileByPath(filePath)) {
      filePath = `${folder}/${sanitized} ${counter}.md`;
      counter++;
    }
    return filePath;
  }
  async ensureFolderExists(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  getExistingNoteTitles() {
    const files = this.app.vault.getMarkdownFiles();
    return files.map((f) => f.basename).slice(0, 50);
  }
  validateSettings() {
    if (this.settings.aiProvider !== "ollama" && !this.settings.apiKey) {
      new import_obsidian3.Notice("Please configure your API key in settings");
      return false;
    }
    if (!this.settings.model) {
      new import_obsidian3.Notice("Please select a model in settings");
      return false;
    }
    return true;
  }
  sanitizeFileName(name) {
    return name.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim().substring(0, 100);
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
var PromptModal = class extends import_obsidian3.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Generate Evergreen Note" });
    contentEl.createEl("p", {
      text: "Enter a prompt, question, or topic to explore:",
      cls: "evergreen-prompt-description"
    });
    this.textArea = contentEl.createEl("textarea", {
      cls: "evergreen-prompt-input",
      attr: {
        placeholder: 'e.g., "Explain how spaced repetition enhances learning"',
        rows: "4"
      }
    });
    this.textArea.style.width = "100%";
    this.textArea.style.marginBottom = "1em";
    this.textArea.style.padding = "0.5em";
    this.textArea.style.resize = "vertical";
    setTimeout(() => this.textArea.focus(), 10);
    const buttonContainer = contentEl.createDiv({ cls: "evergreen-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "0.5em";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
    const generateBtn = buttonContainer.createEl("button", {
      text: "Generate",
      cls: "mod-cta"
    });
    generateBtn.addEventListener("click", () => this.submit());
    this.textArea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        this.submit();
      }
    });
  }
  submit() {
    const prompt = this.textArea.value.trim();
    if (prompt) {
      this.close();
      this.onSubmit(prompt);
    } else {
      new import_obsidian3.Notice("Please enter a prompt");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
